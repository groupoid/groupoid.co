<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Maxim Sokhatsky"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@5HT"><meta name="twitter:creator" content="@5HT"><meta name="twitter:image" content="https://groupoid.space/card2.png?v=1"><meta property="og:title" content="Groupoid Infinity"><meta property="og:image" content="https://groupoid.space/card2.png?v=1"><meta property="og:type" content="website"><meta property="fb:app_id" content="118554188236439"><meta property="og:url" content="https://groupoid.space"><meta property="og:description" content="The Language of Space"><link rel="stylesheet" href="https://groupoid.space/main.css?v=10"><title>TOPOS</title><script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script><script>window.MathJax = { jax: ["input/TeX", "input/MathML", "input/AsciiMath", "output/CommonHTML", "output/NativeMML"],
                        TeX: { extensions: ["AMSmath.js", "AMSsymbols.js", "autoload-all.js"] },
                        extensions: ["tex2jax.js", "asciimath2jax.js", "mml2jax.js", "MathMenu.js", "MathZoom.js"],
                        "HTML-CSS": { imageFont: null },
                        AuthorInit: function() {
                            MathJax.Hub.Register.StartupHook("TeX AMSmath Ready", function() {
                                var TEX = MathJax.InputJax.TeX;
                                TEX.Definitions.Add({
                                    macros: {
                                      llparenthesis: ['Macro', '\\mathopen{\u2987}'],
                                      rrparenthesis: ['Macro', '\\mathclose{\u2988}'],
                                      llbracket:     ['Macro', '\\mathopen{\u27E6}'],
                                      rrbracket:     ['Macro', '\\mathclose{\u27E7}'],
                                    }
                                });
                            });
                        },
                        tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']],
                                   processEscapes: true }
                    };
</script></head><body class="content"><header class="header"><a href="//groupoid.space/"><img class="header__logo" src="../../groupoid.svg"/></a><div class="header__titles"><h1 class="header__title">Formal Set Topos</h1><h4 class="header__subtitle">Elementary Topos for Category of Sets</h4></div></header><article class="main"><div class="om"><section><h1>Article</h1></section></div><aside>Maxim Sokhatsky<time>DATE: 9 AUG 2018</time></aside><div class="om"><section><p>This page gives you minimal single-file setup for
Set Topos instance in <a href="https://homotopytypetheory.org/2017/09/16/a-hands-on-introduction-to-cubicaltt/">cubicaltt</a>.
As for base library this is a chance to unvail the simplicity
for the domain of intersection of: category
theory, set theory, and topos theory.</p><p>As for category thoery we need only pullbacks and mono
for defining the topos and terminals for cartesian closure.</p><p>Disputed foundations for set theory could be taken as:
ZFC, NBG, ETCS, Topoi. The motivation for topos theory for us
is the localization modality, and geometric morphisms of sheaf topoi.
As a free cocompletion, presheaf categories includes categorical model of sets
as presheaf is a functor from opposite ctegory to category of sets.</p><p>We will disctinct syntetically: i) category theory, mainly for pullbacks,
ii) set theory in univalent foundations, and iii) topos theory for formulating
geometric moriphisms between presheaf topoi.</p><p>One can admit two topos theory lineages. One lineage takes its roots from published
by Jean Leray in 1945 initial work on sheaves and specral sequences. Later this lineage
was developed by Henri Paul Cartan, Andr√© Weil. Its peak this lineage has achived
with works by Jean-Pierre Serre, Alexander Grothendieck, and Roger Godement.
Alexander Grothendieck proposed to use topology information on top of
categorical information.</p><p>Second remarkable lineage take its root from Williame Lawvere (ETCS) and
Myles Tierney. The main contribution is the reformulation of Grothendieck topology
by using sobobject classifier, subclassing topology information from categorical
structure of topos. Our aim is to show this substantiation.
</p><h1>Category Theory</h1><p>We give here only minimal set of definitions needed for instantiating
elementary topos of category of sets.
</p><h2>Structure</h2><p><b>Definition</b> (Category Signature). The signature of category is
a $\Sigma_{A:U}A \rightarrow A \rightarrow U$ where $U$ could be any universe.
The $\mathrm{pr}_1$ projection is called $\mathrm{Ob}$ and $\mathrm{pr}_2$ projection is
called $\mathrm{Hom}(a,b)$, where $a,b:\mathrm{Ob}$.</p><code>cat: U = (A: U) * (A -> A -> U)
</code><h2>Category</h2><p>Precategory $\mathrm{C}$ defined as set of $\mathrm{Hom}_C(a,b)$ where $a,b:\mathrm{Ob}_C$
are objects defined by its $\mathrm{id}$ arrows $\mathrm{Hom}_C(x,x)$.
Properfies of left and right units included with composition c
and its associativity.</p><code>isPrecategory (C: cat): U
  = (id: (x: C.1) -> C.2 x x)
  * (c: (x y z: C.1) -> C.2 x y -> C.2 y z -> C.2 x z)
  * (homSet: (x y: C.1) -> isSet (C.2 x y))
  * (left: (x y: C.1) -> (f: C.2 x y) -> Path (C.2 x y) (c x x y (id x) f) f)
  * (right: (x y: C.1) -> (f: C.2 x y) -> Path (C.2 x y) (c x y y f (id y)) f)
  * ( (x y z w: C.1) -> (f: C.2 x y) -> (g: C.2 y z) -> (h: C.2 z w) ->
    Path (C.2 x w) (c x z w (c x y z f g) h) (c x y w f (c y z w g h)))</code><p><b>Definition</b> (Precategory). More formal, precategory $\mathrm{C}$ consists of the following.
(i) A type $\mathrm{Ob}_C$, whose elements are called objects;
(ii) for each $a,b: \mathrm{Ob}_C$, a set $\mathrm{Hom}_C(a,b)$, whose elements are called arrows or morphisms.
(iii) For each $a: \mathrm{Ob}_C$, a morphism $1_a : \mathrm{Hom}_C(a,a)$, called the identity morphism.
(iv) For each $a,b,c: \mathrm{Ob}_C$, a function
$\mathrm{Hom}_C(b,c) \rightarrow Hom_C(a,b) \rightarrow \mathrm{Hom}_C(a,c)$
called composition, and denoted $g \circ f$.
(v) For each $a,b: \mathrm{Ob}_C$ and $f: \mathrm{Hom}_C(a,b)$,
$f = 1_b \circ f$ and $f = f \circ 1_a$.
(vi) For each $a,b,c,d: A$ and
$f: \mathrm{Hom}_C(a,b)$, $g: \mathrm{Hom}_C(b,c)$, $h: \mathrm{Hom}_C(c,d)$,
$h \circ (g \circ f ) = (h \circ g) \circ f$.</p><code>carrier (C: precategory) : U
hom     (C: precategory) (a b: carrier C) : U
compose (C: precategory) (x y z: carrier C)
        (f: hom C x y) (g: hom C y z) : hom C x z
</code><h2>Terminal</h2><p><b>Definition</b> (Terminal Object). Is such object $\mathrm{Ob}_C$,
that $\Pi_{x,y:\mathrm{Ob}_C} \mathrm{isContr}(\mathrm{Hom}_C(y,x))$.</p><code>isTerminal (C: precategory) (y: carrier C): U = (x: carrier C) -> isContr (hom C x y)
terminal   (C: precategory): U = (y: carrier C) * isTerminal C y
</code><h2>Pullback</h2><p><b>Definition</b> (Categorical Pullback).</p><code>homTo  (C: precategory) (X: carrier C): U   = (Y: carrier C) * hom C Y X
cospan (C: precategory): U = (X: carrier C) * (_: homTo C X) * homTo C X

hasCospanCone (C: precategory) (D: cospan C) (W: carrier C) : U
  = (f: hom C W D.2.1.1)
  * (g: hom C W D.2.2.1)
  * Path (hom C W D.1)
         (compose C W D.2.1.1 D.1 f D.2.1.2)
         (compose C W D.2.2.1 D.1 g D.2.2.2)

cospanCone (C: precategory) (D: cospan C): U = (W: carrier C) * hasCospanCone C D W
isCospanConeHom (C: precategory) (D: cospan C) (E1 E2: cospanCone C D) (h: hom C E1.1 E2.1) : U
  = (_ : Path (hom C E1.1 D.2.1.1) (compose C E1.1 E2.1 D.2.1.1 h E2.2.1)   E1.2.1)
  * (    Path (hom C E1.1 D.2.2.1) (compose C E1.1 E2.1 D.2.2.1 h E2.2.2.1) E1.2.2.1)

cospanConeHom (C: precategory) (D: cospan C) (E1 E2: cospanCone C D) : U
  = (h: hom C E1.1 E2.1) * isCospanConeHom C D E1 E2 h
isPullback (C: precategory) (D: cospan C) (E: cospanCone C D) : U
  = (h: cospanCone C D) -> isContr (cospanConeHom C D h E)
hasPullback (C: precategory) (D: cospan C) : U
  = (E: cospanCone C D) * isPullback C D E
</code><br><h1>Set Theory</h1><h2>SET</h2><p><b>Definition</b> ($\mathrm{SET}$).</p><code>data N = Z  | S (n: N)

n_grpd (A: U) (n: N): U = (a b: A) -> rec A a b n where
   rec (A: U) (a b: A) : (k: N) -> U
     = split { Z -> Path A a b ; S n -> n_grpd (Path A a b) n }

isContr (A: U): U = (x: A) * ((y: A) -> Path A x y)
isProp  (A: U): U = n_grpd A Z
isSet   (A: U): U = n_grpd A (S Z)

PROP  : U = (X:U) * isProp X
SET   : U = (X:U) * isSet X
</code><h2>Pi Contractability</h2><p><b>Theorem</b> ($\Pi$-Contractability). if fiber is set thene
path space between any sections is contractible.</p><code>setPi  (A: U) (B: A -> U) (h: (x: A) -> isSet (B x)) (f g: Pi A B)
       (p q: Path (Pi A B) f g)
     : Path (Path (Pi A B) f g) p q</code><h2>Sigma Contractability</h2><p><b>Theorem</b> ($\Sigma$-Contractability). if fiber is set then $\Sigma$ is set.</p><code>setSig (A:U) (B: A -> U) (sA: isSet A)
       (sB : (x:A) -> isSet (B x)) : isSet (Sigma A B)
</code><h2>Unit</h2><p><b>Theorem</b> ($1$ is a proposition).</p><code>propUnit : isProp unit</code><p><b>Theorem</b> ($1$ is a set).</p><code>setUnit : isSet unit
</code><h2>Category of Sets</h2><p><b>Theorem</b> ($\mathrm{Set}$). Sets forms a Category.
All compositional theorems proved by using refleation rule of internal language.
The proof that $\mathrm{Hom}$ forms a set is taken through $\Pi$-contractability.</p><code>Set: precategory = ((Ob,Hom),id,c,HomSet,L,R,Q) where
  Ob: U = SET
  Hom (A B: Ob): U = A.1 -> B.1
  id (A: Ob): Hom A A = idfun A.1
  c (A B C: Ob) (f: Hom A B) (g: Hom B C): Hom A C = o A.1 B.1 C.1 g f
  HomSet (A B: Ob): isSet (Hom A B) = setFun A.1 B.1 B.2
  L (A B: Ob) (f: Hom A B): Path (Hom A B) (c A A B (id A) f) f = refl (Hom A B) f
  R (A B: Ob) (f: Hom A B): Path (Hom A B) (c A B B f (id B)) f = refl (Hom A B) f
  Q (A B C D: Ob) (f: Hom A B) (g: Hom B C) (h: Hom C D)
   : Path (Hom A D) (c A C D (c A B C f g) h) (c A B D f (c B C D g h))
   = refl (Hom A D) (c A B D f (c B C D g h))
</code><br><h1>Topos Theory</h1><p>Topos theory extends categorical set theory
with cartesian closure and subobject classifier.
</p><h2>Mono</h2><p><b>Definition</b> (Monomorphism).</p><code>mono (P: precategory) (Y Z: carrier P) (f: hom P Y Z): U
  = (X: carrier P) (g1 g2: hom P X Y)
 -> Path (hom P X Z) (compose P X Y Z g1 f) (compose P X Y Z g2 f)
 -> Path (hom P X Y) g1 g2
</code><h2>Subobject Classifier</h2><p><b>Definition</b> (Subobject Classifier).</p><code>subobjectClassifier (C: precategory): U
  = (omega: carrier C)
  * (end: terminal C)
  * (trueHom: hom C end.1 omega)
  * (xi: (V X: carrier C) (j: hom C V X) -> hom C X omega)
  * (square: (V X: carrier C) (j: hom C V X) -> mono C V X j
    -> hasPullback C (omega,(end.1,trueHom),(X,xi V X j)))
  * ((V X: carrier C) (j: hom C V X) (k: hom C X omega)
    -> mono C V X j
    -> hasPullback C (omega,(end.1,trueHom),(X,k))
    -> Path (hom C X omega) (xi V X j) k)</code><p><b>Theorem</b> (Category of Sets has Subobject Classifier).
</p><h2>Cartesian Closure</h2><p><b>Definition</b> (Cartesian Closed Categories).
The category $\mathrm{C}$ is called cartesian closed if exists all
products, terminals and exponentials. Note that this definition
is lack beta and eta rules which could be found in embedding $\mathrm{MLTT}$.</p><code>isCCC (C: precategory): U
  = (Exp:   (A B: carrier C) -> carrier C)
  * (Prod:  (A B: carrier C) -> carrier C)
  * (Apply: (A B: carrier C) -> hom C (Prod (Exp A B) A) B)
  * (P1:    (A B: carrier C) -> hom C (Prod A B) A)
  * (P2:    (A B: carrier C) -> hom C (Prod A B) B)
  * (Term:  terminal C)
  * unit</code><p><b>Theorem</b> (Category of Sets has Cartesian Closure). As you can see
from exp and pro we internalize $\Pi$ and $\Sigma$ types as $\mathrm{SET}$ instances,
the $\mathrm{isSet}$ predicates are provided with contractability.
Exitense of terminals is proved by $\mathrm{propPi}$. The same technique you
can find in $\mathrm{MLTT}$ embedding.</p><code>cartesianClosure : isCCC Set
  = (expo,prod,appli,proj1,proj2,term,tt) where
  exp (A B: SET): SET = (A.1   -> B.1, setFun A.1 B.1 B.2)
  pro (A B: SET): SET = (prod A.1 B.1,
    setSig A.1 (\(_ : A.1) -> B.1) A.2 (\(_ : A.1) -> B.2))
  expo:  (A B: SET) -> SET = \(A B: SET) -> exp A B
  prod:  (A B: SET) -> SET = \(A B: SET) -> pro A B
  appli: (A B: SET) -> hom Set (pro (exp A B) A) B
    = \(A B:SET)-> \(x:(pro(exp A B)A).1)-> x.1 x.2
  proj1: (A B: SET) -> hom Set (pro A B) A = \(A B: SET) (x: (pro A B).1) -> x.1
  proj2: (A B: SET) -> hom Set (pro A B) B = \(A B: SET) (x: (pro A B).1) -> x.2
  unitContr (x: SET) (f: x.1 -> unit) : isContr (x.1 -> unit)
    = (f, \(z: x.1 -> unit) -> propPi x.1 (\(_:x.1)->unit) (\(x:x.1) ->propUnit) f z)
  term: terminal Set = ((unit,setUnit),\(x: SET) -> unitContr x (\(z: x.1) -> tt))
</code><h2>Grothendieck Topos</h2><p><b>Definition</b> (Coverage). A coverage is a function assigning
to each $\mathrm{Ob}_C$ the family of mprphisms ${f_i : U_i \rightarrow U}_{i\in I}$ called
covering families, such that for any $g: V \rightarrow U$ exist
a covering family ${h:V_j \rightarrow V}_{j \in J}$ such that
each composite $h_j \circ g$ factors some $f_i$:
$$
\def\mapright#1{\xrightarrow{{#1}}}
\def\mapdown#1{\Big\downarrow\rlap{\raise2pt{\scriptstyle{#1}}}}
\def\mapdiagl#1{\vcenter{\searrow}\rlap{\raise2pt{\scriptstyle{#1}}}}
\def\mapdiagr#1{\vcenter{\swarrow}\rlap{\raise2pt{\scriptstyle{#1}}}}
\begin{array}{ccc}
    V_j & \mapright{k} & U_i \\
    \mapdown{} & \square & \mapdown{} \\
    V & \mapright{g} & U \\
\end{array}
$$</p><p><b>Definition</b> (Site). Site is a category having a coverage.</p><code>site (C: precategory): U = (C: precategory) * hasCoverage C</code><p><b>Definition</b> (Presheaf). Presheaf of a category $\mathrm{C}$
is a functor from opposite category to category of sets:
$\mathrm{C}^{op} \rightarrow \mathrm{Set}$.</p><code>presheaf (C: precategory): U = catfunctor (opCat C) Set</code><p><b>Definition</b> (Grothendieck Topos). A category $\mathrm{C}$
is called Grothendieck Topos if exists a site such that category of
sheaves on $\mathrm{C}$ equals $\mathrm{C}$ or $\mathrm{Sh}(\mathrm{C},J)=\mathrm{C}$.
In other words a topos is the category of sheaves $\mathrm{Sh}(\mathrm{C},J)$ on a site.
</p><h2>Elementary Topos</h2><p><b>Definition</b> (Elementary Topos). Topos.</p><code>Topos (cat: precategory)
  : U
  = (cartesianClosure: isCCC cat)
  * subobjectClassifier cat</code><p><b>Theorem</b> (Category of Sets forms a Topos).</p><code>internal
  : Topos Set
  = (cartesianClosure,hasSubobject)</code></section></div></article><footer class="footer"><img class="footer__logo" src="https://longchenpa.guru/seal.png" width="50"><span class="footer__copy">2016&mdash;2018 &copy; <a href="//groupoid.space/team.html" style="color:white;">Groupoid Infinity</a></span></footer><script src="https://groupoid.space/bundle.js"></script><script src="https://groupoid.space/highlight.js?v=8"></script></body></html>