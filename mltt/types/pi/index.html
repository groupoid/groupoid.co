<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Maxim Sokhatsky"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content="@5HT"><meta name="twitter:creator" content="@5HT"><meta name="twitter:image" content="https://groupoid.space/card2.png?v=1"><meta property="og:title" content="Groupoid Infinity"><meta property="og:image" content="https://groupoid.space/card2.png?v=1"><meta property="og:type" content="website"><meta property="fb:app_id" content="118554188236439"><meta property="og:url" content="https://groupoid.space"><meta property="og:description" content="The Language of Space"><link rel="stylesheet" href="https://groupoid.space/main.css?v=10"><title>PI</title><script src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script><script>window.MathJax = { jax: ["input/TeX", "input/MathML", "input/AsciiMath", "output/CommonHTML", "output/NativeMML"],
                        TeX: { extensions: ["AMSmath.js", "AMSsymbols.js", "autoload-all.js"] },
                        extensions: ["tex2jax.js", "asciimath2jax.js", "mml2jax.js", "MathMenu.js", "MathZoom.js"],
                        "HTML-CSS": { imageFont: null },
                        AuthorInit: function() {
                            MathJax.Hub.Register.StartupHook("TeX AMSmath Ready", function() {
                                var TEX = MathJax.InputJax.TeX;
                                TEX.Definitions.Add({
                                    macros: {
                                      llparenthesis: ['Macro', '\\mathopen{\u2987}'],
                                      rrparenthesis: ['Macro', '\\mathclose{\u2988}'],
                                      llbracket:     ['Macro', '\\mathopen{\u27E6}'],
                                      rrbracket:     ['Macro', '\\mathclose{\u27E7}'],
                                    }
                                });
                            });
                        },
                        tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']],
                                   processEscapes: true }
                    };
</script></head><body class="content"><article class="main"><div class="om"><section><h1>pi</h1></section></div><aside><a href="..">Base Library</a><time>Published: 16 OCT 2017</time></aside><div class="om"><section><figure>$$\def\mapright#1{\xrightarrow{{#1}}}
  \def\mapdown#1{\Big\downarrow\rlap{\raise2pt{\scriptstyle{#1}}}}
  \def\mapdiagl#1{\vcenter{\searrow}\rlap{\raise2pt{\scriptstyle{#1}}}}
  \def\mapdiagr#1{\vcenter{\swarrow}\rlap{\raise2pt{\scriptstyle{#1}}}}
$$</figure><p><a href="https://raw.githubusercontent.com/groupoid/infinity/master/priv/pi.ctt">Pi package</a>
contains basic theorems about Pi types.
Pi type is built in core of any dependent type checker.
Type checker with Pi only type are called Pure Type Systems.
See <a href="https://groupoid.space/pts/pure">OM</a> for
our Erlang implementation.</p><code>Pi (A: U) (P: B -> U): U = (x: A) -> B x</code><p>From algebraic geometry point of view Pi type is a space of sections,
while the dependent codomain is a space of fibrations.
Lambda functions are sections or points in these spaces,
while the function result is a fibration. Pi type also represents
the cartesian family of sets, generalizing
the cartesian product of sets.
</p></section><section><h1>Definitions</h1><p>Thre prerequisite to fibrational interpretation is
a <a href="../bundle/">Bundle</a> package.</p><p><b>Definition</b> (Cartesian Product of Family of Sets). Is a set $F$
of sections of the bundle with elimination map $app : F \times B \rightarrow E$.
such that</p><figure>$$
    F \times B \mapright{\mathbf{app}} E \mapright{\mathbf{pr_1}} B
$$</figure><p>$pr_1$ is a product projection, so $pr_1$, $app$ are moriphisms
of slice category $Set_{/B}$. The universal mapping property of $F$:
for all $A$ and morphism $A \times B \rightarrow E$ in $Set_{/B}$ exists
unique map $A \rightarrow F$ such that everthing commute. So a category
with all dependent products is necessarily a category with all pullbacks.</p><p><b>Definition</b> (Dependent Product). For a category $C$ and morphism
$g: B \rightarrow A$ such that base change functor exists: $\Delta_f: C_{/A} \rightarrow C_{/B}$,
and has right adjoin functor $\Pi_f : C_{/B} \rightarrow C_{/A}$ which
is called Dependent Product.</p><p><b>Definition</b> (Product Type Construction). Let $\mathbf{H}$ be
a $(\infty,1)$-topos, and let $E \rightarrow B : \mathbf{H}_{/B}$ a bundle in
$\mathbf{H}$, object in the slice topos. Then the space of sections $\Gamma_\Sigma(E)$
of this bundle is the Dependent Product:</p><figure>$$
    \Gamma_\Sigma(E) = \Pi_\Sigma (E) \in \mathbf{H}.
$$
</figure><br><h2>Introduction</h2><code>lam (A: U) (B: A -> U)
    (a: A) (b: B a): A -> B a = \ (x: A) -> b

lambda (A B: U) (b: B): A -> B = \ (x: A) -> b</code><p>Lambda constructor defines a new lambda closure that could be
saved or passed by in context.</p><h2>Operations</h2><br><code>ot (A B C: U) : U
 = (B -> C) -> (A -> B) -> (A -> C)

o (A B C: U) (f: B -> C) (g: A -> B) :
       A -> C = \ (x: A) -> f (g x)

funcomp (F G: U -> U) (t: U): U = F (G t)</code><br><code>flip    (A B C: U) (f: A -> B -> C) (b: B) (a: A)
      : C = f a b

uncurry (A: U) (B: U) (C : prod A B -> U)
        (f: (x: A) -> (y: B) -> C (x,y))
      : (p: prod A B) -> C p
      = \ (p: prod A B) -> f p.1 p.2</code><br><h1>Eliminator</h1><br><code>app (A: U) (B: A -> U)
    (a: A) (f: A -> B a): B a = f a

apply (A B: U) (f: A -> B) (x: A): B = f(x)</code><p>Application reduces the term by using recursive substitution.
</p><h1>Computation</h1><h2>Beta</h2><p></p><code>Pi_Beta (A: U) (B: A -> U) (a: A) (f: A -> B a)
      : Path (B a) (app A B a (lam A B a (f a))) (f a)
      = refl (B a) (f a)</code><p>Beta rule shows that composition $lam \circ app$ could be fused.</p><h2>Eta</h2><code>Pi_Eta (A: U) (B: A -> U) (a: A) (f: A -> B a)
      : Path (A -> B a) f (\(x:A) -> f x)
      = refl (A -> B a) f</code><p>Eta rule shows that composition $app \circ lam$ could be fused.</p></section></div></article><footer class="footer"><img class="footer__logo" src="https://longchenpa.guru/seal.png" width="50"><span class="footer__copy">2016&mdash;2018 &copy; <a href="//groupoid.space/team.html" style="color:white;">Groupoid Infinity</a></span></footer><script src="https://groupoid.space/bundle.js"></script><script src="https://groupoid.space/highlight.js?v=8"></script></body></html>