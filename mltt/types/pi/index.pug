extends ../../../layout.pug

block title
    title PI
    script(src='//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML')
    script.
     window.MathJax = { jax: ["input/TeX", "input/MathML", "input/AsciiMath", "output/CommonHTML", "output/NativeMML"],
                             TeX: { extensions: ["AMSmath.js", "AMSsymbols.js", "autoload-all.js"] },
                             extensions: ["tex2jax.js", "asciimath2jax.js", "mml2jax.js", "MathMenu.js", "MathZoom.js"],
                             "HTML-CSS": { imageFont: null },
                             AuthorInit: function() {
                                 MathJax.Hub.Register.StartupHook("TeX AMSmath Ready", function() {
                                     var TEX = MathJax.InputJax.TeX;
                                     TEX.Definitions.Add({
                                         macros: {
                                           llparenthesis: ['Macro', '\\mathopen{\u2987}'],
                                           rrparenthesis: ['Macro', '\\mathclose{\u2988}'],
                                           llbracket:     ['Macro', '\\mathopen{\u27E6}'],
                                           rrbracket:     ['Macro', '\\mathclose{\u27E7}'],
                                         }
                                     });
                                 });
                             },
                             tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']],
                                        processEscapes: true }
                         };

block content
    article.main
        .om
            section
                h1 pi
        aside <a href="..">Base Library</a>
            time Published: 16 OCT 2017
        .om
            section
                figure.
                    $$\def\mapright#1{\xrightarrow{{#1}}}
                      \def\mapdown#1{\Big\downarrow\rlap{\raise2pt{\scriptstyle{#1}}}}
                      \def\mapdiagl#1{\vcenter{\searrow}\rlap{\raise2pt{\scriptstyle{#1}}}}
                      \def\mapdiagr#1{\vcenter{\swarrow}\rlap{\raise2pt{\scriptstyle{#1}}}}
                    $$
                p.
                    <a href="https://raw.githubusercontent.com/groupoid/infinity/master/priv/pi.ctt">Pi package</a>
                    contains basic theorems about Pi types.
                    Pi type is built in core of any dependent type checker.
                    Type checker with Pi only type are called Pure Type Systems.
                    See <a href="https://groupoid.space/pts/pure">OM</a> for
                    our Erlang implementation.
                code.
                    Pi (A: U) (P: B -> U): U = (x: A) -> B x
                p.
                    From algebraic geometry point of view Pi type is a space of sections,
                    while the dependent codomain is a space of fibrations.
                    Lambda functions are sections or points in these spaces,
                    while the function result is a fibration. Pi type also represents
                    the cartesian family of sets, generalizing
                    the cartesian product of sets.

            section
                h1 Definitions
                p.
                    Thre prerequisite to fibrational interpretation is
                    a <a href="../bundle/">Bundle</a> package.
                p.
                    <b>Definition</b> (Cartesian Product of Family of Sets). Is a set $F$
                    of sections of the bundle with elimination map $app : F \times B \rightarrow E$.
                    such that
                figure.
                    $$
                        F \times B \mapright{\mathbf{app}} E \mapright{\mathbf{pr_1}} B
                    $$
                p.
                    $pr_1$ is a product projection, so $pr_1$, $app$ are moriphisms
                    of slice category $Set_{/B}$. The universal mapping property of $F$:
                    for all $A$ and morphism $A \times B \rightarrow E$ in $Set_{/B}$ exists
                    unique map $A \rightarrow F$ such that everything commute. So a category
                    with all dependent products is necessarily a category with all pullbacks.
                p.
                    <b>Definition</b> (Dependent Product). For a category $C$ and morphism
                    $g: B \rightarrow A$ such that base change functor exists: $\Delta_f: C_{/A} \rightarrow C_{/B}$,
                    and has right adjoin functor $\Pi_f : C_{/B} \rightarrow C_{/A}$ which
                    is called Dependent Product.
                p.
                    <b>Definition</b> (Section). A section of morphism $f: A \rightarrow B$
                    in some category is the morphism $g: B \rightarrow A$ such that
                    $f \circ g: B \mapright{g} A \mapright{f} B$ equals the identity morphism on B.
                p.
                    <b>Definition</b> (Space of Sections). Let $\mathbf{H}$ be
                    a $(\infty,1)$-topos, and let $E \rightarrow B : \mathbf{H}_{/B}$ a bundle in
                    $\mathbf{H}$, object in the slice topos. Then the space of sections $\Gamma_\Sigma(E)$
                    of this bundle is the Dependent Product:
                figure.
                    $$
                        \Gamma_\Sigma(E) = \Pi_\Sigma (E) \in \mathbf{H}.
                    $$

                br
                h2 Introduction
                code.
                    lam (A: U) (B: A -> U)
                        (a: A) (b: B a): A -> B a = \ (x: A) -> b

                    lambda (A B: U) (b: B): A -> B = \ (x: A) -> b
                p.
                    Lambda constructor defines a new lambda closure that could be
                    saved or passed by in context.
                h2 Operations
                br
                code.
                    ot (A B C: U) : U
                     = (B -> C) -> (A -> B) -> (A -> C)

                    o (A B C: U) (f: B -> C) (g: A -> B) :
                           A -> C = \ (x: A) -> f (g x)

                    funcomp (F G: U -> U) (t: U): U = F (G t)
                br
                code.
                    flip    (A B C: U) (f: A -> B -> C) (b: B) (a: A)
                          : C = f a b

                    uncurry (A: U) (B: U) (C : prod A B -> U)
                            (f: (x: A) -> (y: B) -> C (x,y))
                          : (p: prod A B) -> C p
                          = \ (p: prod A B) -> f p.1 p.2
                br

                h1 Eliminator
                br
                code.
                    app (A: U) (B: A -> U)
                        (a: A) (f: A -> B a): B a = f a

                    apply (A B: U) (f: A -> B) (x: A): B = f(x)
                p.
                    Application reduces the term by using recursive substitution.

                h1 Computation
                h2 Beta
                p.
                code.
                    Pi_Beta (A: U) (B: A -> U) (a: A) (f: A -> B a)
                          : Path (B a) (app A B a (lam A B a (f a))) (f a)
                          = refl (B a) (f a)
                p.
                    Beta rule shows that composition $lam \circ app$ could be fused.
                h2 Eta
                code.
                    Pi_Eta (A: U) (B: A -> U) (a: A) (f: A -> B a)
                          : Path (A -> B a) f (\(x:A) -> f x)
                          = refl (A -> B a) f
                p.
                    Eta rule shows that composition $app \circ lam$ could be fused.
