extends ../../layout.pug

block title
    title HOMOLOGY
    script(src='https://etale.space/styles/mathjax.js?config=TeX-AMS_HTML')
    script.
     window.MathJax = { jax: ["input/TeX", "input/MathML", "input/AsciiMath", "output/CommonHTML", "output/NativeMML"],
                             TeX: { extensions: ["AMSmath.js", "AMSsymbols.js", "autoload-all.js"] },
                             extensions: ["tex2jax.js", "asciimath2jax.js", "mml2jax.js", "MathMenu.js", "MathZoom.js"],
                             "HTML-CSS": { imageFont: null },
                             AuthorInit: function() {
                                 MathJax.Hub.Register.StartupHook("TeX AMSmath Ready", function() {
                                     var TEX = MathJax.InputJax.TeX;
                                     TEX.Definitions.Add({
                                         macros: {
                                           llparenthesis: ['Macro', '\\mathopen{\u2987}'],
                                           rrparenthesis: ['Macro', '\\mathclose{\u2988}'],
                                           llbracket:     ['Macro', '\\mathopen{\u27E6}'],
                                           rrbracket:     ['Macro', '\\mathclose{\u27E7}'],
                                         }
                                     });
                                 });
                             },
                             tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']],
                                        processEscapes: true }
                         };

block content
    article.main
        .semantics
            section
                h1 HOMOLOGY
        aside <a href="..">Base Library</a>
            time Published: 16 OCT 2017
        .semantics
            section
                figure.
                    $$\def\mapright#1{\xrightarrow{{#1}}}
                      \def\mapdown#1{\Big\downarrow\rlap{\raise2pt{\scriptstyle{#1}}}}
                      \def\mapup#1{\Big\uparrow\rlap{\raise2pt{\scriptstyle{#1}}}}
                      \def\mapdiagl#1{\vcenter{\searrow}\rlap{\raise2pt{\scriptstyle{#1}}}}
                      \def\mapdiagr#1{\vcenter{\swarrow}\rlap{\raise2pt{\scriptstyle{#1}}}}
                    $$
                p.
                    <a href="https://raw.githubusercontent.com/groupoid/cubical/master/src/homology.ctt">Homology package</a>
                    contains basic theorems about general homology theory.

            section
                h1 SETS
                p.
                    <b>Definition</b> (Set).
                code.
                  n_grpd (A: U) (n: N): U = (a b: A) -> rec A a b n where
                    rec (A: U) (a b: A) : (k: N) -> U
                      = split { Z -> Path A a b ; S n -> n_grpd (Path A a b) n }

                  isProp  (A: U): U = n_grpd A Z
                  isSet   (A: U): U = n_grpd A (S Z)
                p.
                br.

                h1 GROUPS
                p.
                    <b>Definition</b> (Monoid).
                code.
                  isMonoid (M: SET): U
                    = (op: M.1 -> M.1 -> M.1)
                    * (assoc: isAssociative M.1 op)
                    * (id: M.1)
                    * (hasIdentity M.1 op id)

                  ismonoidhom (a b: monoid) (f: a.1.1 -> b.1.1): U
                    = (_: preservesOp a.1.1 b.1.1 (opGroup a) (opGroup b) f)
                    * (preservesId a.1.1 b.1.1 (idGroup a) (idGroup b) f)

                  monoidhom (a b: monoid): U
                    = (f: a.1.1 -> b.1.1)
                    * (ismonoidhom a b f)

                p.
                    <b>Definition</b> (Group).
                code.
                  isGroup (G: SET): U
                    = (m: isMonoid G)
                    * (inv: G.1 -> G.1)
                    * (hasInverse G.1 m.1 m.2.2.1 inv)

                  opGroup  (g: group): g.1.1 -> g.1.1 -> g.1.1
                  idGroup  (g: group): g.1.1
                  invGroup (g: group): g.1.1 -> g.1.1

                p.
                    <b>Definition</b> (Differential Group).
                code.
                  isDifferentialGroup (G: SET): U
                    = (g: isGroup G)
                    * (comm: isCommutative G.1 g.1.1)
                    * (boundary: G.1 -> G.1)
                    * ((x: G.1) -> Path G.1 (boundary (boundary x)) g.1.2.2.1)

                  dgroup: U = (X: SET) * isDifferentialGroup X
                  dgrouphom (a b: dgroup): U = monoidhom (a.1, a.2.1.1) (b.1, b.2.1.1)
                  unitDGroup: dgroup
                p.
                    <b>Definition</b> (Diff).
                code.
                  diff (H: group) (g h: H.1.1) : H.1.1
                    = (opGroup H) g ((invGroup H) h)
                p.
                    <b>Definition</b> (Conjugation).
                    Let $G$ is a group, the conjucation of two elements of the group
                    $x,y \in G$ is defined as $x y x^{-1}$.
                code.
                  conjugate (G: group) (g1 g2: G.1.1): G.1.1
                    = diff G ((opGroup G) g1 g2) g1
                p.
                br.

                h1 SUBGROUPS
                p.
                    <b>Definition</b> (Subtype).
                code.
                  subtypeProp (A: U): U
                    = (P: A -> U) * (a: A) -> isProp (P a)

                  subtype (A: U) (P: subtypeProp A): U
                    = (x: A) * (P.1 x)
                p.
                    <b>Definition</b> (Subgroup).
                code.
                  subgroupProp (G: group): U
                    = (prop: G.1.1 -> U)
                    * (level: (x: G.1.1) -> isProp (prop x))
                    * (ident: prop (idGroup (G.1,G.2.1)))
                    * ((g1 g2: G.1.1) -> prop g1 -> prop g2 -> prop (diff G g1 g2))
                p.
                    <b>Definition</b> (Normal Subgroup).
                code.
                  isNormal (G: group) (P: subgroupProp G) : U
                    = (g1 g2: G.1.1) -> P.1 g2 -> P.1 (conjugate G g1 g2)

                  normalSubgroupProp (G: group): U
                    = (P: subgroupProp G)
                    * isNormal G P

                  subElProp (G: group) (H: subgroupProp G)
                    : subtypeProp G.1.1
                    = (H.1,H.2.1)

                  subEl (G: group) (H: subgroupProp G): U
                    = subtype G.1.1 (subElProp G H)
                p.
                br.

                h1 KERNEL and IMAGE
                p.
                    <b>Definition</b> (Kernel of Homomorphism).
                code.
                  Ker (G: abgroup) (H: group) (phi: grouphom (G.1,G.2.1) H): group
                    = subgroup (G.1,G.2.1) (kerProp (G.1,G.2.1) H phi)
                p.
                    <b>Theorem</b> (Kernel of Homomorphism is subgroup).
                code.
                  kerProp (G H: group) (phi: grouphom G H)
                    : subgroupProp G
                p.
                    <b>Definition</b> (Image of Homomorphism).
                code.
                  Im (G: group) (H: abgroup) (psi: grouphom G (H.1,H.2.1)): group
                    = subgroup (H.1,H.2.1) (imProp G (H.1,H.2.1) psi)
                p.
                    <b>Theorem</b> (Image of Homomorphism is subgroup).
                code.
                  imProp (G H: group) (phi: grouphom G H)
                    : subgroupProp H
                p.
                    <b>Definition</b> (Factor Group).
                code.
                  factorProp (G : group) (P : subgroupProp G) : G.1.1 -> G.1.1 -> U
                    = \(x y : G.1.1) -> P.1 (diff G x y)

                  factor (G : group) (P : subgroupProp G) : U
                      = setquot G.1.1 (factorProp G P)
                p.
                    <b>Definition</b> (Homology Group).
                code.
                  homology_group (x: ChainComplex): (n: Z) -> group

                p.
                    <b>Theorem</b> (First Group Isomorphism Theorem). Let $G$ and $H$ be groups,
                    and let $\phi : G \rightarrow H$ be a homomorphism. Then: 1) The kernel of $\phi$ is normal subgroup of G;
                    2) The image of $\phi$ is a subgroup of $H$; 3) The image of $\phi$ is isomorphic to the quotient group $G/ker(\phi)$.
                figure.
                    $$
                    \begin{array}{ccc}
                        \phi (g_1 \cdot g_2 \cdot g_1^{-1}) & \mapright{unfold} & \phi(g_1) \cdot \phi(g_2) \cdot (\phi (g_1))^{-1}  \\
                        \mapup{} & & \mapup{} \\
                        \phi (g_1 \cdot g_2) \cdot \phi(g_1)^{-1} & \mapright{} & \phi(g_1) \cdot \phi(g_2) \cdot \phi (g_1)^{-1} \\
                    \end{array}
                    $$
                br.
                code.
                  kernelIsNormalSubgroup (G H : group) (phi : grouphom G H)
                    : normalSubgroupProp G
                p.
                br.

                h1 COMPLEXES
                p.
                    <b>Definition</b> (Sequence).
                code.
                  mutual
                    data Seq (A: U) (B: A -> A -> U)
                       = seqNil (ob: A)
                       | seqCons (ob: A) (seq: Seq A B) (hom: B ob (head A B seq))
                    head (A: U) (B: A -> A -> U): Seq A B -> A = split
                         seqNil x -> x
                         seqCons x y z -> x
                p.
                    <b>Definition</b> (Chain Complexes).
                code.
                  ChainComplex: U
                    = (sequence: Seq abgroup abgrouphom)
                    * (index: nat -> abgroup)
                    * (augment: abgrouphom (index zero) (head abgroup abgrouphom sequence))
                    * ((n: nat) -> abgrouphom (index (succ n)) (index n))

                  CoChainComplex: U
                    = (sequence: Seq abgroup abgrouphom)
                    * (index: nat -> abgroup)
                    * (augment: abgrouphom (head abgroup abgrouphom sequence) (index zero))
                    * ((n: nat) -> abgrouphom (index n) (index (succ n)))
                p.
                br.

                h1 AXIOMS
                p.
                    <b>Definition</b> (Homology). The map from a pair of topological
                    spaces $A \subset X$ to an Abelian Groups, called homological
                    groups $H_n(X,A)$ iff: i) Any map $f : (X,A) \rightarrow (Y,B)$
                    induces homomorphism $f_* : H_n(X,A) \rightarrow H_n(Y,B)$ such that
                    $id_* = id : H_n(X,A) \rightarrow H_n(X,A)$, $(f \circ g)_* = f_* \circ g_*$
                    ii) There is unique homomorphism
                    $\delta : H_n(X,A) \rightarrow H_{n-1}(A) = H_{n-1}(A,\varnothing)$
                    such that
                figure.
                    $$
                    \begin{array}{ccc}
                        H_n(X,A) & \mapright{\mathbf{\delta}} & H_{n-1}(A) \\
                        \mapdown{\mathbf{f_*}} & & \mapdown{\mathbf{f*}} \\
                        H_n(Y,B) & \mapright{\mathbf{\delta}} & H_{n-1}(B) \\
                    \end{array}
                    $$
                p.
