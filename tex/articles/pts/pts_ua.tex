\documentclass{article}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage[english,russian,ukrainian]{babel}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{cite}
\usepackage{url}
\usepackage{tikz}
\usepackage{tikz-cd}
\usetikzlibrary{matrix}
\usetikzlibrary{babel}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage[only,llbracket,rrbracket,llparenthesis,rrparenthesis]{stmaryrd}

\lstset{basicstyle=\small,inputencoding=utf8}
\begin{document}

\title{Система доведення теорем з однією аксіомою}
\author{Максим Сохацький}
\date{ $^1$ Національний технічний університет України \\
       \small ім. Ігоря Сікорського\\
       \today }

\maketitle

\begin{abstract}
Ця стаття презентує диайн мови програмування \textbf{PTS$^\infty$}, імпліментації її типового верифікатора,
а також екстрактор байткоду для віртуальної машини Erlang від Ericsson. \textbf{PTS$^\infty$} — це
мова проміжного рівня заснована на так званій чистій системі типів, або системі типів з однією аксіомою та
зліченною кількістью всесвітів (консистента теорія залежних типів). Ця мова програмування дає зручну
мову проміжного рівня для застосунку у додадках з підвищеними вимогами до математичної верифікації.
Типовий верифікатор побудований за базі MLTT принципів та конфігурується правилами для предикативної та імпредактивної ієрархії всесвітів.
Синтаксис цієї мови програмування сумісний з базовим синтаксистом мови Morte, та підтримує її базову бібліотеку,
а також додає поняття нескінченної кількості всесвітів. Дуже базова бібліотека прилюдії з рекрурсивним та
корекурсивним вводом-вивдом додаються як частина цієї роботи. Це дає змогу застосовувати основи
математичної верифікації до нескінченних або довго-живучих процесів.

Ми коротко опишемо мову верхнього рівня, та мову проміжного ядра для описаного в статті типового верифікатора,
та покажемо місце цієї мови у конценптуальній системі доведення теорем, яка передбачає поєднання: 1) оптимального лямбда обчислювача;
2) мову з однією аксіомою; 3) MLTT мову; 4) мову з гомотопічними типами та інтервалом.
\end{abstract}

\newpage
\tableofcontents
\newpage

\section{Вступ}
IEEE\footnote{IEEE Std 1012-2016  --- V\&V Software verification and validation} стандарт
та регуляторні документи ESA\footnote{ESA PSS-05-10 1-1 1995 -- Guide to software verification and validation} 
визначають набір інструментів та підходів для процесу валідації та верифікації програмногоо забезпечення
Найбіль розширені техніки передбачають застосування математичної логіки та теорії доведення теорем для
формулювання виробничих задач у математичній формі для формальної перевірки коректності таких програм на всії області визначення функції
з доведення властивостей цих функцій.

Ера верифікованих теорем, типових верифікатори та систем доведення теорем бере свій початок з доводжувача теорем AUTOMATH та теорії типів Мартіна-Льофа.
Станом на сьогодні ми маємо такі потужні системи як Coq, Agda, Leam, F* які базуються на CoC (Calculus of Constructions, Coquand)
та CiC (Calculus of Inductive Constructions, Paulin-Mohring). Подальший розвиток систематизації призвів до лямбда кубу та чистим
системам з одією аксіомою, як узагальнюючому визначенню ситсем типу CoC, AUT-68, ECC, Henk, Morte, PTS$^\infty$.
Головна мотивація систем з однією аксіомою — це простота імплементації та простота формальної імпленетації
нормалізатора термів, як термінального обчислення. За допомогою формальної мови та типового верифікатора ми можемо
передавати програми по відкритих каналах які задовільняють формальним типовим специфікацям та складним теоремам як властивостями цих об'єктів.
У якості областей застосування тут можно виділити наступні сфери: 1) мови смарт-контрактів; 2) сертифіковані DSL; 3) платіжні системи, тощо.

\subsection{Екстракція математично-доведених програм}
Завдяки ізоморфізму Каррі-Ламбека-Ховарда — відповідності всередині теорії типів Мартіна-Льофа\cite{Lof84} між доведеннями, моделями та програмами,
де типи, сигнатури та категорії є просторами (мовами) які містять у собі точки (програми), можемо трактувати терми як программи для обчислення певного результату,
і природа цього обчислення може буде повністю позбавлена типізації, що дає змогу виконувати такі доведення на практивно довільному інтерпретаторі,
так як майже всі так чи інакше реалізують модель лямбда-числення, тут маються на увазі мови JavaScript, Erlang, PyPy, LuaJIT, K. Також можна будувати
екстрактори з інтераналізацією в C++, Rust. Ця робота головним чином презентує екстрактор в байт-код віртуальної машини Erlang, як модель
простого нетипизованого лямбда числення, накшталт LISP або Smalltalk.

\subsection{Системна архітектура}
\textbf{PTS$^\infty$} як мова програмування реалізую чисту систему типів, але зі зліченною кількістю всесвітів.
Ця система типів формує основне мовне ядро системи доведення теорем, усі інші системи типів  містять чисту систему типів
як підкатегорію у свому спектрі, та є її нащадками. З точки зору наслідкових зв'язків чиста система типів є
основою усіх системах типів побудованих на розшаруваннях, $\Pi$-типах, а також систем здатних до доведення теорем.

Поверх цієї базової ситеми типів виділяються інші системи типів які можна звести теж до одно-аксіоматичних систем
з чітко-вираженим кодуваннями ізоморфізмів. До концептуальної моделі системи доведення теорем включатимемо
наступні мовні ядра:
1) Мова з індуктивними типами для доведення у стилі математичної індукції;
2) Гомотопічне ядро з відкритим інтервалом для доведення у кубічному стилі;
3) Числення отоків як базис для тензорного числення (Futhark);
4) Числення процесів як базис для лінійних типів, коіндуктивного моделювання та середовища виконання.
Незважаючи на те, що з усіх цих мовних рівней існують функтори в систему з однією аксіомою, ці мовні розширення
програмуються як окремі плагіни функтори які погружаються у головний цикл типового верифікатора разом зі своїми правилами.
Це дозволяє пришвидшити виконання нормалізації термів у процесі типової верифікації.

Однак не всі вищі мови можуть бути розкладені в базисі PTS.
Як було показано Geuvers\cite{Geuvers01} ми не можемо побудувати принцип індукції всередині чистої PTS, ми повинні послабити
до залучення оператора нерухомої точки принаймі для типової специфікації самого індуктивного рекурсивного типу.
Також ми не можемо побудувати елімінатор рівності та функціональну екстенсіональність. Але незважаючи на це PTS
це потужна система яка відразу дає змогу генерувати сертифіковані програми з доведених теорем. Властивосі можуть доводитися
у інших мовах концептуальної моделі системи доведення теорем. Прошарок PTS більшим чином пов'язаний з мовою цільового інтерпретатору.

Як подальший розвиток цього проекту ми бачимо долучення індуктивної ситсеми типів та гомотопічної системи типів.

\subsection{Місце серед інших мов}
Продукт який представлено у статті виконаний для телекомунікаційної платформи Erlang/OTP від Ericsson,
що дало змогу використовувати доведені програми на цій віртуальній машині. Цей додаток експонує наступні
сервісу у середовищі Erlang: 1) типова верифікація; 2) нормалізація; 3) екстракція.
Усі частини системи \textbf{PTS$^\infty$} написані на мові Erlang та виключно для системи Erlang.

\begin{itemize}
\item Рівень 0 --- сертифікований векторизований інтерпретатор
\item {\bf Рівень 1 --- консистентна система з однією аксіомою}
\item Рівень 2 --- вища мова для доведення теорем та перевірки властивостей
\end{itemize}

\begin{table}[h]
\begin{center}
\caption{Список мов, досліджених у якості цільової платформи для екстракції}
\label{tab:a}
\tabcolsep7pt\begin{tabular}{lcccc}
\hline
{\bf Target} & {\bf Class} & {\bf Intermediate} & {\bf Theory}\\
\hline
C++        & компілятор/native      & HNC & System F\\
Rust       & компілятор/native      & HNC & System F\\
JVM        & інтерпретатор/native   & Java    & F-sub\footnote{System F wit bounded quantification}\\
JVM        & інтерпретатор/native   & Scala   & System F-omega\\
GHC Core   & компілятор/native      & Haskell & System D\\
GHC Core   & компілятор/native      & Morte   & CoC\\
Haskell    & компілятор/native      & Coq     & CiC\\
OCaml      & компілятор/native      & Coq     & CiC\\
{\bf BEAM} & {\bf інтерпретатор} & {\bf Om}   & {\bf PTS$^\infty$} \\
O          & інтерпретатор          & Om  & PTS$^\infty$ \\
K          & інтерпретатор          & Q   & Applicative \\
PyPy       & інтерпретатор/native   & N/A & ULC \\
LuaJIT     & інтерпретатор/native   & N/A & ULC \\
JavaScript & інтерпретатор/native & PureScript & System F\\
\hline
\end{tabular}
\end{center}
\end{table}

\section{Консистентна мова проміжного рівня}
The {\bf Om} language is a dependently typed lambda calculus {\bf PTS$^\infty$}, an extension of Coquand' Calculus of Constructions\cite{Coq88} with the predicative hierarchy of indexed universes.
There is no fixpoint axiom, so there is no infinite term dependence, the theory is fully consistent and has strong normalization property.

All terms respect ranking {\bf Axioms} inside the sequence of universes {\bf Sorts} and complexity of the dependent term is equal to the maximum complexity of term and its dependency {\bf Rules}.
The universe system is completely described by the following PTS notation due to Barendregt\cite{Henk93}:

$$
\begin{cases}
Sorts = Type.\{i\},\ i : Nat\\
Axioms = Type.\{i\} : Type.\{inc\ i\}\\
Rules = Type.\{i\} \leadsto Type.\{j\} : Type.\{max\ i\ j\}\\
\end{cases}
$$

The {\bf Om} language is based on Henk languages described first by Erik Meijer and Simon Peyton Jones in 1997\cite{Erik97}.
Later on in 2015 Morte implementation of Henk design appeared in Haskell, using the Boem-Berrarducci encoding of non-recursive lambda terms.
It is based only on one type constructor {\bf $\Pi$}, its intro {\bf $\lambda$} and apply eliminator, infinite number of universes, and {\bf $\beta$}-reduction.
The design of Om language resemble Henk and Morte both in design and in implementation.
This language intended to be small, concise, easy provable and able to produce the verifiable piece of code that can be distributed over the networks, compiled at the target platform with a safe linkage.

\subsection{БНФ та Синтаксичне Дерево}

{\bf Om} syntax is compatible with CoC presented in Morte and Henk languages.
However, it has extension in a part of specifying universe index as a {\bf Nat} number.
Traditionally we present the language in Backus-Naur form.
Equivalent AST tree encoding from the right side.

\begin{lstlisting}[mathescape=true]
   <> ::= #option                  data pts = star (n: nat)
    V ::= #identifier                       | var (n: name)
    S ::= * < #number >                     | app (f a: pts)
    O ::= S | V | ( O )                     | lambda (x: name) (d c: pts)
        | O O | O $\rightarrow$ O                        | pi (x: name) (d c: pts)
        | $\lambda$ ( I : O ) $\rightarrow$ O
        | $\forall$ ( I : O ) $\rightarrow$ O
\end{lstlisting}

\subsection{Всесвіти}

As {\bf Om} has infinite number of universes it should include metatheoretical {\bf Nat} inductive type in its core.
{\bf Om} supports predicative and impredicative hierarchies.

$$
U_0 : U_1 : U_2 : U_3 : ...
$$

Where $U_0$ --- propositions, $U_1$ --- sets, $U_2$ --- types and $U_3$ --- kinds, etc.

\begin{equation}
\tag{I}
\dfrac
{}
{Nat}
\end{equation}

\begin{equation}
\tag{S}
\dfrac
{o : Nat}
{Type_o}
\end{equation}

You may check if a term is a universe with the star function.
If an argument is not a universe it returns $\{error,\_\}$.

\begin{lstlisting}[mathescape=true]
star (:star,N) $\rightarrow$ N
             _ $\rightarrow$ (:error, "*")
\end{lstlisting}

\subsection{Предикативні всесвіти}

All terms obey the {\bf Axioms} ranking inside the sequence of {\bf Sorts} universes, and the complexity {\bf Rules} of the dependent term is equal to a maximum of the term's complexity and its dependency.
Note that predicative universes are incompatible with Church lambda term encoding.
You choose either predicative or impredicative universes with a type checker parameter.

\[
\tag{$A_1$}
\dfrac{i: Nat, j: Nat, i < j}{Type_i : Type_j}
\]

\[
\tag{$R_1$}
\dfrac{i : Nat, j : Nat}{Type_i \rightarrow Type_j : Type_{max(i,j)} }
\]

\subsection{Impredicative Universes}
Propositional contractible bottom space is the only available extension to the predicative hierarchy which doesn't lead to inconsistency.
However, there is another option to have the infinite impredicative hierarchy.

\begin{equation}
\tag{$A_2$}
\dfrac
{i: Nat}
{Type_i : Type_{i+1}}
\end{equation}

\begin{equation}
\tag{$R_2$}
\dfrac
{i : Nat,\ \ \ \ j : Nat}
{Type_i \rightarrow Type_{j} : Type_{j}}
\end{equation}

\subsection{Переклюлчення ієрархій}
Function {\bf h} returns the target Universe of B term dependence on A.
There are two dependence rules known as the predicative one and the impredicative one which returns max universe or universe of the last term respectively.

\begin{lstlisting}[mathescape=true]
dep A B :impredicative $\rightarrow$ B
    A B :predicative   $\rightarrow$ max A B

h A B $\rightarrow$ dep A B :impredicative
\end{lstlisting}

\subsection{Contexts}
The contexts model a dictionary with variables for type checker.
It can be typed as the list of pairs or {\bf List\ Sigma}.
The elimination rule is not given here as in our implementation the whole dictionary is destroyed after type checking.

\begin{equation}
\tag{Ctx-formation}
\dfrac
{}
{\Gamma : Context}
\end{equation}

\begin{equation}
\tag{Ctx-intro$_1$}
\dfrac
{\Gamma : Context}
{Empty : \Gamma}
\end{equation}

\begin{equation}
\tag{Ctx-intro$_2$}
\dfrac
{A : Type_i,\ \ \ \ x : A,\ \ \ \ \Gamma : Context}
{(x : A)\ \vdash\ \Gamma : Context}
\end{equation}

\subsection{Система з однією аксіомою}

This language is called one axiom language (or pure) as eliminator
and introduction rules inferred from type formation rule.
The only computation rule of Pi type is called beta-reduction.
Computational rules of language are called operational semantics
and establish equality of substitution and lambda application.
Operational semantics in that way defines the rewrite rules of computations.

\begin{equation}
\tag{$\Pi$-formation}
\dfrac
{x:A \vdash B : Type}
{\Pi\ (x:A) \rightarrow B : Type}
\end{equation}

\begin{equation}
\tag{$\lambda$-intro}
\dfrac
{x:A \vdash b : B}
{\lambda\ (x:A) \rightarrow b : \Pi\ (x: A) \rightarrow B }
\end{equation}

\begin{equation}
\tag{$App$-elimination}
\dfrac
{f: (\Pi\ (x:A) \rightarrow B)\ \ \ a: A}
{f\ a : B\ [a/x]}
\end{equation}

\begin{equation}
\tag{$\beta$-computation}
\dfrac
{x:A \vdash b: B\ \ \ a:A}
{(\lambda\ (x:A) \rightarrow b)\ a = b\ [a/x] : B\ [a/x]}
\end{equation}

\begin{equation}
\tag{subst}
\dfrac
{\pi_1 : A\ \ \ \ u:A \vdash \pi_2 : B}
{[\pi_1/u]\ \pi_2 : B}
\end{equation}

The theorems (specification) of PTS could be embedded in itself and used as
Logical Framework for the Pi type. Here is the example in the higher language.

\begin{lstlisting}[mathescape=true]
record Pi (A: Type) :=
       (intro:  (A $\rightarrow$ Type) $\rightarrow$ Type)
       (lambda: (B: A $\rightarrow$ Type) $\rightarrow$ pi A B $\rightarrow$ intro B)
       (app:    (B: A $\rightarrow$ Type) $\rightarrow$ intro B $\rightarrow$ pi A B)
       (applam: (B: A $\rightarrow$ Type) (f: pi A B) $\rightarrow$ (a: A) $\rightarrow$
                Path (B a) ((app B (lambda B f)) a) (f a))
       (lamapp: (B: A $\rightarrow$ Type) (p: intro B) $\rightarrow$
                Path (intro B) (lambda B ($\lambda$ (a:A) $\rightarrow$ app B p a)) p)
\end{lstlisting}

The proofs intentionally left blank, as it proofs could be taken from various sources \cite{Henk93}.
The equalities of computational semantics presented here as {\bf Path} types in the higher language.

The {\bf Om} language is the extention of the {\bf PTS$^\infty$} with the remote AST node which means remote file loading from trusted storage, anyway this will be checked by the type checker.
We deny recursion over the remote node.
We also add an index to var for simplified de Bruijn indexes, we allow overlapped names with tags, incremented on each new occurrence.

\begin{lstlisting}[mathescape=true]
data om = star             (n: nat)
        | var    (n: name) (n: nat)
        | remote (n: name) (n: nat)
        | pi     (x: name) (n: nat) (d c: om)
        | fn     (x: name) (n: nat) (d c: om)
        | app                       (f a: om)
\end{lstlisting}

Our typechecker differs from cannonical example of Coquand\cite{Coq96}. 
We based our typechecker on variable {\bf Substitution}, variable {\bf Shifting}, term {\bf Normalization}, definitional {\bf Equality} anf {\bf Type Checker} itself.

\subsection{Верифікатор}
For sure in a pure system, we should be careful with {\bf :remote} AST node.
Remote AST nodes like {\bf \#List/Cons or \#List/map} are remote links to files.
So using trick one should desire circular dependency over {\bf :remote}.

\begin{lstlisting}[mathescape=true]
type (:star,N)         D $\rightarrow$ (:star,N+1)
     (:var,N,I)        D $\rightarrow$ :true = proplists:is_defined N B, om:keyget N D I
     (:remote,N)       D $\rightarrow$ om:cache (type N D)
     (:pi,N,0,I,O)     D $\rightarrow$ (:star,h(star(type I D)),star(type O [(N,norm I)|D]))
     (:fn,N,0,I,O)     D $\rightarrow$ let star (type I D), NI = norm I
                             in (:pi,N,0,NI,type(O,[(N,NI)|D]))
     (:app,F,A)        D $\rightarrow$ let T = type(F,D),
                                (:pi,N,0,I,O) = T, :true = eq I (type A D)
                             in norm (subst O N A)
\end{lstlisting}

\newpage
\subsection{Зсув індексів де Брейна}
Shift renames var N in B. Renaming means adding 1 to the nat component of variable.

\begin{lstlisting}[mathescape=true]
  sh (:star,X)       N P $\rightarrow$ (:star,X)
     (:var,N,I)      N P $\rightarrow$ (:var,N,I+1) when I >= P
                         $\rightarrow$ (:var,N,I)
     (:remote,X)     N P $\rightarrow$ (:remote,X)
     (:pi,N,0,I,O)   N P $\rightarrow$ (:pi,N,0,sh I N P,sh O N P+1)
     (:fn,N,0,I,O)   N P $\rightarrow$ (:fn,N,0,sh I N P,sh O N P+1)
     (:app,L,R)      N P $\rightarrow$ (:app,L,R)
\end{lstlisting}

\subsection{Підстановка}
Substitution replaces variable occurance in terms.

\begin{lstlisting}[mathescape=true]
 sub (:star,X)     N V L $\rightarrow$ (:star,X)
     (:var,N,L)    N V L $\rightarrow$ V
     (:var,N,I)    N V L $\rightarrow$ (:var,N,I-1) when I > L
     (:remote,X)   N V L $\rightarrow$ (:remote,X)
     (:pi,N,0,I,O) N V L $\rightarrow$ (:pi,N,0,sub I N V L,sub O N (sh V N 0) L+1)
     (:pi,F,X,I,O) N V L $\rightarrow$ (:pi,F,X,sub I N V L,sub O N (sh V F 0) L)
     (:fn,N,0,I,O) N V L $\rightarrow$ (:fn,N,0,sub I N V L,sub O N (sh V N 0) L+1)
     (:fn,F,X,I,O) N V L $\rightarrow$ (:fn,F,X,sub I N V L,sub O N (sh V F 0) L)
     (:app,F,A)    N V L $\rightarrow$ (:app,   sub F N V L,sub A N V L)
\end{lstlisting}

\subsection{Нормалізація}
Normalization performs substitutions on applications to functions (beta-reduction)
by recursive entrance over the lambda and pi nodes.

\begin{lstlisting}[mathescape=true]
norm (:star,X)     $\rightarrow$ (:star,X)
     (:var,X)      $\rightarrow$ (:var,X)
     (:remote,N)   $\rightarrow$ cache (norm N [])
     (:pi,N,0,I,O) $\rightarrow$ (:pi,N,0,norm I,norm O)
     (:fn,N,0,I,O) $\rightarrow$ (:fn,N,0,norm I,norm O)
     (:app,F,A)    $\rightarrow$ case norm F of
                         (:fn,N,0,I,O) $\rightarrow$ norm (subst O N A)
                                    NF $\rightarrow$ (:app,NF,norm A) end
\end{lstlisting}

\newpage
\subsection{Рівність}
Definitional Equality simply checks the equality of Erlang terms.

\begin{lstlisting}[mathescape=true]
  eq (:star,N)        (:star,N)        $\rightarrow$ true
     (:var,N,I)       (:var,(N,I))     $\rightarrow$ true
     (:remote,N)      (:remote,N)      $\rightarrow$ true
     (:pi,N1,0,I1,O1) (:pi,N2,0,I2,O2) $\rightarrow$
          let :true = eq I1 I2
           in eq O1 (subst (shift O2 N1 0) N2 (:var,N1,0) 0)
     (:fn,N1,0,I1,O1) (:fn,N2,0,I2,O2) $\rightarrow$
          let :true = eq I1 I2
           in eq O1 (subst (shift O2 N1 0) N2 (:var,N1,0) 0)
     (:app,F1,A1)       (:app,F2,A2)   $\rightarrow$ let :true = eq F1 F2 in eq A1 A2
     (A,B)                             $\rightarrow$ (:error,(:eq,A,B))
\end{lstlisting}

\section{Використання мови}
Here we will show some examples of {\bf Om} language usage.
In this section, we will show two examples.
One is lifting PTS system to MLTT system by defining {\bf Sigma} and {\bf Equ} types using only {\bf Pi} type.
We will use Bohm inductive dependent encoding\cite{Bohm85}.
The second is to show how to write real world programs in {\bf Om} that performs input/output operations within Erlang environment.
We show both recursive (finite, routine) and corecursive (infinite, coroutine, process) effects.

\begin{lstlisting}
$ ./om help me
[{a,[expr],"to parse. Returns {_,_} or {error,_}."},
 {type,[term],"typechecks and returns type."},
 {erase,[term],"to untyped term. Returns {_,_}."},
 {norm,[term],"normalize term. Returns term's normal form."},
 {file,[name],"load file as binary."},
 {str,[binary],"lexical tokenizer."},
 {parse,[tokens],"parse given tokens into {_,_} term."},
 {fst,[{x,y}],"returns first element of a pair."},
 {snd,[{x,y}],"returns second element of a pair."},
 {debug,[bool],"enable/disable debug output."},
 {mode,[name],"select metaverse folder."},
 {modes,[],"list all metaverses."}]

$ ./om print fst erase norm a "#List/Cons"
   \ Head
-> \ Tail
-> \ Cons
-> \ Nil
-> Cons Head (Tail Cons Nil)
ok
\end{lstlisting}


\subsection{Сігма тип}
The PTS system is extremely powerful even without {\bf Sigma} type.
But we can encode {\bf Sigma} type similar how we encode {\bf Prod} tuple pair in Bohm encoding.
Let's formulate {\bf Sigma} type as an inductive type in higher language.

\begin{lstlisting}
data Sigma (A: Type) (P: A -> Type) (x: A): Type =
     (intro: P x -> Sigma A P)
\end{lstlisting}

The {\bf Sigma-type} with its eliminators appears as example in Aaron Stump \cite{Stump17}.
Here we will show desugaring to {\bf PTS$^\infty$}.

\begin{lstlisting}
-- Sigma/@
   \ (A: *)
-> \ (P: A -> *)
-> \ (n: A)
-> \/ (Exists: *)
-> \/ (Intro: A -> P n -> Exists)
-> Exists

-- Sigma/Intro
   \ (A: *)
-> \ (P: A -> *)
-> \ (x: A)
-> \ (y: P x)
-> \ (Exists: *)
-> \ (Intro: \/ (x:A) -> P x -> Exists)
-> Intro x y

-- Sigma/fst
   \ (A: *)
-> \ (B: A -> *)
-> \ (n: A)
-> \ (S: #Sigma/@ A B n)
-> S A ( \(x: A) -> \(y: B n) -> x)

-- Sigma/snd
   \ (A: *)
-> \ (B: A -> *)
-> \ (n: A)
-> \ (S: #Sigma/@ A B n)
-> S (B n) ( \(_: A) -> \(y: B n) -> y )
\end{lstlisting}

\begin{lstlisting}[mathescape=true]
> om:fst(om:erase(om:norm(om:a("#Sigma/test.fst")))).
{{$\lambda$,{'Succ',0}},
 {any,{{$\lambda$,{'Zero',0}},{any,{var,{'Zero',0}}}}}}
\end{lstlisting}

For using {\bf Sigma} type for Logic purposes one should change the
home Universe of the type to {\bf Prop}. Here it is:

\begin{lstlisting}[mathescape=true]
data Sigma (A: Prop) (P: A -> Prop): Prop =
     (intro: (x:A) (y:P x) -> Sigma A P)
\end{lstlisting}

\subsection{Тип рівності}
Another example of expressiveness is Equality type a la Martin-Löf.

\begin{lstlisting}
data Equ (A: Type): A -> A -> Type :=
     (refl (a: A): Equ A a a)
\end{lstlisting}

\begin{lstlisting}
-- Equ/@
   \ (A: *)
-> \ (x: A)
-> \ (y: A)
-> \/ (Equ: A -> A -> *)
-> \/ (Refl: \/ (z: A) -> Equ z z)
-> Equ x y
\end{lstlisting}

\begin{lstlisting}
-- Equ/Refl
   \ (A: *)
-> \ (x: A)
-> \ (Equ: A -> A -> *)
-> \ (Refl: \/ (z: A) -> Equ z z)
-> Refl x
\end{lstlisting}

You cannot construct a lambda that will check different values of A type is they are equal,
however, you may want to use built-in definitional equality and
normalization feature of type checker to actually compare two values:

\begin{lstlisting}[mathescape=true]
> om:print(om:type(
  om:a("(\\ (z: #Equ/@ #Nat/@ #Nat/One #Nat/One) -> #Prop/True)"++
       " (#Equ/Refl #Nat/@ (#Nat/Succ #Nat/Zero))"))).
   \/ (True: *0)
-> \/ (Intro: True)
-> True
ok

> om:print(om:type(
  om:a("(\\ (z: #Equ/@ #Nat/@ #Nat/One #Nat/One) -> #Prop/True)"++
       " (#Equ/Refl #Nat/@ #Nat/Zero)"))).
** exception error: no match of right hand side value
   {error,{"==",
          {app,{{var,{'Succ',0}},{var,{'Zero',0}}}},
          {var,{'Zero',0}}}}
\end{lstlisting}

\subsection{Система ефектів}
This work is expected to compile to a limited number of target platforms.
For now, Erlang, Haskell, and LLVM are awaiting.
Erlang version is expected to be used both on LING and BEAM Erlang virtual machines.
This language allows you to define trusted operations in System F and extract this routine to Erlang/OTP platform and plug as trusted resources.
As the example, we also provide infinite coinductive process creation and inductive shell that linked to Erlang/OTP IO functions directly.

{\bf IO} protocol.
We can construct in pure type system the state machine based on (co)free monads driven by {\bf IO/IOI} protocols.
Assume that {\bf String} is a {\bf List\ Nat} (as it is in Erlang natively), and three external constructors: getLine, putLine and pure.
We need to put correspondent implementations on host platform as parameters to perform the actual IO.

\begin{lstlisting}
String: Type = List Nat
data IO: Type =
     (getLine: (String -> IO) -> IO)
     (putLine: String -> IO)
     (pure: () -> IO)
\end{lstlisting}

\subsubsection{Нескінченний ввід-вивід}

Infinity I/O Type Spec.

\begin{lstlisting}
-- IOI/@: (r: U) [x: U] [[s: U] -> s -> [s -> #IOI/F r s] -> x] x
   \ (r : *)
-> \/ (x : *)
-> (\/ (s : *)
   -> s
   -> (s -> #IOI/F r s)
   -> x)
-> x

-- IOI/F
   \ (a : *)
-> \ (State : *)
-> \/ (IOF : *)
-> \/ (PutLine_ : #IOI/data -> State -> IOF)
-> \/ (GetLine_ : (#IOI/data -> State) -> IOF)
-> \/ (Pure_ : a -> IOF)
-> IOF

-- IOI/MkIO
   \ (r : *)
-> \ (s : *)
-> \ (seed : s)
-> \ (step : s -> #IOI/F r s)
-> \ (x : *)
-> \ (k : forall (s : *) -> s -> (s -> #IOI/F r s) -> x)
-> k s seed step

-- IOI/data
#List/@ #Nat/@
\end{lstlisting}

Infinite I/O Sample Program.

\begin{lstlisting}[mathescape=true]
-- Morte/corecursive
( \ (r: *1)
 -> ( (((#IOI/MkIO r) (#Maybe/@ #IOI/data)) (#Maybe/Nothing #IOI/data))
    ( \ (m: (#Maybe/@ #IOI/data))
     -> (((((#Maybe/maybe #IOI/data) m) ((#IOI/F r) (#Maybe/@ #IOI/data)))
           ( \ (str: #IOI/data)
            -> ((((#IOI/putLine r) (#Maybe/@ #IOI/data)) str)
                (#Maybe/Nothing #IOI/data))))
         (((#IOI/getLine r) (#Maybe/@ #IOI/data))
          (#Maybe/Just #IOI/data))))))
\end{lstlisting}

Erlang Coinductive Bindings.

\begin{lstlisting}[mathescape=true]
copure() ->
    fun (_) -> fun (IO) -> IO end end.

cogetLine() ->
    fun(IO) -> fun(_) ->
        L = ch:list(io:get_line("> ")),
        ch:ap(IO,[L]) end end.

coputLine() ->
    fun (S) -> fun(IO) ->
        X = ch:unlist(S),
        io:put_chars(": "++X),
        case X of "0\n" -> list([]);
                      _ -> corec() end end end.

corec() ->
    ap('Morte':corecursive(),
        [copure(),cogetLine(),coputLine(),copure(),list([])]).
\end{lstlisting}

\begin{lstlisting}[mathescape=true]

> om_extract:extract("priv/normal/IOI").
ok
> Active: module loaded: {reloaded,'IOI'}
\end{lstlisting}

\begin{lstlisting}[mathescape=true]
> om:corec().
> 1
: 1
> 0
: 0
#Fun<List.3.113171260>
\end{lstlisting}

\subsubsection{Скінченний ввід-вивід}

I/O Type Spec.

\begin{lstlisting}[mathescape=true]
-- IO/@
   \ (a : *)
-> \/ (IO : *)
-> \/ (GetLine_ : (#IO/data -> IO) -> IO)
-> \/ (PutLine_ : #IO/data -> IO -> IO)
-> \/ (Pure_ : a -> IO)
-> IO

-- IO/replicateM
   \ (n: #Nat/@)
-> \ (io: #IO/@ #Unit/@)
-> #Nat/fold n (#IO/@ #Unit/@)
               (#IO/[>>] io)
               (#IO/pure #Unit/@ #Unit/Make)
\end{lstlisting}

Guarded Recursion I/O Sample Program.

\begin{lstlisting}[mathescape=true]
-- Morte/recursive
((#IO/replicateM #Nat/Five)
 ((((#IO/[>>=] #IO/data) #Unit/@) #IO/getLine) #IO/putLine))
\end{lstlisting}

Erlang Inductive Bindings.

\begin{lstlisting}[mathescape=true]
pure() ->
    fun(IO) -> IO end.

getLine() ->
    fun(IO) -> fun(_) ->
        L = ch:list(io:get_line("> ")),
        ch:ap(IO,[L]) end end.

putLine() ->
    fun (S) -> fun(IO) ->
        io:put_chars(": "++ch:unlist(S)),
        ch:ap(IO,[S]) end end.

rec() ->
    ap('Morte':recursive(),
        [getLine(),putLine(),pure(),list([])]).
\end{lstlisting}


Here is example of Erlang/OTP shell running recursive example.

\begin{lstlisting}[mathescape=true]
> om:rec().
> 1
: 1
> 2
: 2
> 3
: 3
> 4
: 4
> 5
: 5
#Fun<List.28.113171260>
\end{lstlisting}

\section{Вища мова з індуктивними типами}
As was shown by Herman Geuvers\cite{Geuvers01} the induction principle is not derivable in second-order dependent type theory.
However there a lot of ways doing this. For example, we can build in induction principal into the core for every defined inductive type.
We even can allow recursive type check for only terms of induction principle, which have recursion base --- that approach was successfully established by Peng Fu and Aaron Stump\cite{Stump17}.
In any case for derivable induction principle in PTS$^\infty$ we need to have fixpoint somehow in the core.

So-called Calculus of Inductive Constructions\cite{Mohring15} is used as a top language on top of PTS to reason about inductive types.
Here we will show you a sketch of such inductive language model which intended to be a language extension to PTS system.
CiC is allowing fixpoint for any terms, and base checking should be performed during type checking such terms.

Our future top language is a general-purpose functional language with $\Pi$ and $\Sigma$ types, recursive algebraic types, higher order functions, corecursion, and a free monad to encode effects.
It compiles to a small MLTT core of dependent type system with inductive types and equality.
It also has an Id-type (with its recursor) for equality reasoning, Case analysis over inductive types.

\subsection{БНФ}

\begin{lstlisting}[mathescape=true]
    <> ::= #option
    [] ::= #list
     | ::= #sum
     1 ::= #unit
     I ::= #identifier
     U ::= Type < #nat >
     T ::= 1 | ( I : O ) T
     F ::= 1 | I : O = O , F
     B ::= 1 | [ | I [ I ] $\rightarrow$ O ]
     O ::= I | ( O ) |
           U | O $\rightarrow$ O                  | O O
             | fun ( I : O ) $\rightarrow$ O      | fst O
             | snd O                 | id O O O
             | J O O O O O           | let F in O
             | ( I : O ) * O         | ( I : O ) $\rightarrow$ O
             | data I T : O := T     | record I T : O := T
             | case O B
\end{lstlisting}

\newpage
\subsection{Синтаксичне дерево}
The AST of higher language is formally defined using itself.
Here you can find telescopes (context lists), split and its branches, inductive data definitions.

\begin{lstlisting}[mathescape=true]
 data tele (A: U)   = emp | tel (n: name) (b: A) (t: tele A)
 data branch (A: U) =        br (n: name) (args: list name) (term: A)
 data label (A: U)  =       lab (n: name) (t: tele A)
 data ind
    = star                        (n: nat)
    | var    (n: name)            (i: nat)
    | app              (f a: ind)
    | lambda (x: name) (d c: ind)
    | pi     (x: name) (d c: ind)
    | sigma  (n: name) (a b: ind)
    | arrow            (d c: ind)
    | pair             (a b: ind)
    | fst              (p:   ind)
    | snd              (p:   ind)
    | id               (a b: ind)
    | idpair           (a b: ind)
    | idelim           (a b c d e: ind)
    | data_  (n: name) (t: tele ind) (labels:   list (label ind))
    | case   (n: name) (t: ind)      (branches: list (branch ind))
    | ctor   (n: name)               (args:     list ind)
\end{lstlisting}

The Erlang version of parser encoded with OTP library {\bf yecc} which implements LALR-1 grammar generator.
This version resembles the model and slightly based on cubical type checker by Mortberg\cite{Mortberg17} and could be reached at Github repository\footnote{http://github.com/groupoid/infinity/tree/master/priv}.

\subsection{Кодування індуктивних типів}
There are a number of inductive type encodings:
1) Commutative square encoding of F-algebras by Hinze, Wu \cite{Hinze13};
2) Inductive-recursive encoding, algebraic type of algebraic types, inductive family encoding by Dagand \cite{Dagand13};
3) Encoding with motives inductive-inductive definition, also with inductive families, for modeling quotient types by Altenkirch, Kaposi \cite{Kaposi16};
4) Henry Ford encoding or encoding with Ran,Lan-extensions by Hamana, Fiore \cite{Hamana11};
5) Church-compatible Bohm-Berarducci encoding Bohm, Berarducci \cite{Bohm85}.
Om is shipped with base library in Church encoding and we already gave the example of IO system encoded with runtime linkage.
We give here simple calculations behind this theory.

\newpage
\subsection{Поліноміальні функтори}
Least fixed point trees are called well-founded trees.
They encode polynomial functors.\\

\noindent Natural Numbers: $\mu\ X \rightarrow 1 + X$\\
List A: $\mu\ X \rightarrow 1 + A \times X$\\
Lambda calculus: $\mu\ X \rightarrow 1 + X \times X + X$\\
Stream: $\nu\ X \rightarrow A \times X$\\
Potentialy Infinite List A: $\nu\ X \rightarrow 1 + A \times X$\\
Finite Tree: $\mu\ X \rightarrow \mu\ Y \rightarrow 1 + X \times Y = \mu\ X = List\ X$\\

As we know there are several ways to appear for a variable in a recursive algebraic type.
Least fixpoint is known as a recursive expression that has a base of recursion In Chuch-Bohm-Berarducci encoding type are store as non-recursive definitions of their right folds.
A fold in this encoding is equal to id function as the type signature contains its type constructor as parameters to a pure function.

\subsection{Приклад кодування модуля List}
The data type of lists over a given set A can be represented as the initial algebra
$(\mu L_A, in)$ of the functor $L_A(X) = 1 + (A \times X)$. Denote $\mu L_A = List(A)$.
The constructor functions $nil: 1 \rightarrow List(A)$ and
$cons: A \times List(A) \rightarrow List(A)$ are defined by
$nil = in \circ inl$ and $cons = in \circ inr$, so $in = [nil,cons]$.
Given any two functions $c: 1 \rightarrow C$ and $h: A \times C \rightarrow C$,
the catamorphism $f = \llparenthesis [c,h] \rrparenthesis : List(A) \rightarrow C$
is the unique solution of the simultaneous equations:

$$
\begin{cases}
  f \circ nil  = c \\
  f \circ cons = h \circ (id \times f)
\end{cases}
$$

where $f = foldr(c,h)$. Having this the initial algebra is presented with functor
$\mu (1 + A \times X)$ and morphisms sum $[1 \rightarrow List(A), A \times List(A) \rightarrow List(A)]$
as catamorphism. Using this encoding the base library of List will have following form:

$$
\begin{cases}
list = \lambda\ ctor \rightarrow \lambda\ cons \rightarrow \lambda\ nil \rightarrow ctor\\
cons = \lambda\ x\ \rightarrow \lambda\ xs \rightarrow \lambda\ list \rightarrow \lambda\ cons \rightarrow\ \lambda\ nil \rightarrow cons\ x\ (xs\ list\ cons\ nil)\\
nil = \lambda\ list \rightarrow \lambda\ cons \rightarrow \lambda\ nil \rightarrow nil\\
\end{cases}
$$

Here traditionally we show the {\bf List} definition in higher language and its
desugared version in {\bf Om} language.

\begin{lstlisting}[mathescape=true]
  data List: (A: *) $\rightarrow$ * :=
       (Cons: A $\rightarrow$ list A $\rightarrow$ list A)
       (Nil: list A)
\end{lstlisting}

\begin{lstlisting}[mathescape=true]
-- List/@
   \ (A : *)
-> \/ (List: *)
-> \/ (Cons: \/ (Head: A) -> \/ (Tail: List) -> List)
-> \/ (Nil: List)
-> List

-- List/Cons
   \ (A: *)
-> \ (Head: A)
-> \ (Tail:
      \/ (List: *)
   -> \/ (Cons: \/ (Head: A) -> \/ (Tail: List) -> List)
   -> \/ (Nil: List)
   -> List)
-> \ (List: *)
-> \ (Cons:
      \/ (Head: A)
   -> \/ (Tail: List)
   -> List)
-> \ (Nil: List)
-> Cons Head (Tail List Cons Nil)

-- List/Nil
   \ (A: *)
-> \ (List: *)
-> \ (Cons:
      \/ (Head: A)
   -> \/ (Tail: List)
   -> List)
-> \ (Nil: List)
-> Nil
\end{lstlisting}

\begin{lstlisting}[mathescape=true]
           record lists: (A B: *) :=
                  (len: list A $\rightarrow$ integer)
                  ((++): list A $\rightarrow$ list A $\rightarrow$ list A)
                  (map: (A $\rightarrow$ B) $\rightarrow$ (list A $\rightarrow$ list B))
                  (filter: (A $\rightarrow$ bool) $\rightarrow$ (list A $\rightarrow$ list A))
\end{lstlisting}

$$
\begin{cases}
foldr = \llparenthesis [ f \circ nil , h] \rrparenthesis, f \circ cons = h \circ (id \times f)\\
len = \llparenthesis [ zero, \lambda\ a\ n \rightarrow succ\ n ] \rrparenthesis \\
(++) = \lambda\ xs\ ys \rightarrow \llparenthesis [ \lambda (x) \rightarrow ys, cons ] \rrparenthesis (xs) \\
map = \lambda\ f \rightarrow \llparenthesis [ nil, cons \circ (f \times id)] \rrparenthesis
\end{cases}
$$

$$
\begin{cases}
len = foldr\ (\lambda\ x\ n \rightarrow succ\ n)\ 0\\
(++) = \lambda\ ys \rightarrow foldr\ cons\ ys\\
map = \lambda\ f \rightarrow foldr\ (\lambda x\ xs \rightarrow cons\ (f\ x)\ xs)\ nil\\
filter = \lambda\ p \rightarrow foldr\ (\lambda x\ xs \rightarrow if\ p\ x\ then\ cons\ x\ xs\ else\ xs)\ nil\\
foldl = \lambda\ f\ v\ xs = foldr\ (\lambda\ xg\rightarrow\ (\lambda \rightarrow g\ (f\ a\ x)))\ id\ xs\ v\\
\end{cases}
$$

\subsection{Базова бібліотека}
The base library includes basic type-theoretical
building blocks starting from {\bf Unit}, {\bf Bool}, {\bf Either}, {\bf Maybe}, {\bf Nat}, {\bf List} and {\bf IO}.
Here some examples how it looks like. The full listing of Base Library folder
is available at {\bf Om} GitHub repository\footnote{http://github.com/groupoid/om}.

\begin{lstlisting}[mathescape=true]

             data Nat: Type :=
                  (Zero: Unit $\rightarrow$ Nat)
                  (Succ: Nat $\rightarrow$ Nat)

             data List (A: Type) : Type :=
                  (Nil: Unit $\rightarrow$ List A)
                  (Cons: A $\rightarrow$ List A $\rightarrow$ List A)

           record String: List Nat := List.Nil

             data IO: Type :=
                  (getLine: (String $\rightarrow$ IO) $\rightarrow$ IO)
                  (putLint: String $\rightarrow$ IO)
                  (pure: () $\rightarrow$ IO)

           record IO: Type :=
                  (data: String)
                  ([>>=]: ...)

           record Morte: Type :=
                  (recursive: IO.replicateM
                    Nat.Five (IO.[>>=] IO.data Unit
                              IO.getLine IO.putLine))

\end{lstlisting}

\subsection{Вимірювання та порівняння з іншими системами}
The underlying {\bf Om} type checker and compiler is a target language for higher level languages.
The overall size of {\bf Om} language with extractor to Erlang is 265 lines of code.

\begin{table}[h]
\begin{center}
\caption{Compiler Passes}
\label{tab:passes}
\tabcolsep7pt\begin{tabular}{lccc}
\hline
{\bf Module} & {\bf LOC} & {\bf Description}\\
\hline
om\_tok     & 54 LOC & Токенайзер\\
om\_parse   & 81 LOC & Синтаксичний парсер\\
om\_type    & 60 LOC & Нормалізатор та верифікатор\\
om\_erase   & 36 LOC & Стирання типів\\
om\_extract & 34 LOC & Екстракція Erlang байткоду\\
\hline
\end{tabular}
\end{center}
\end{table}

\section{Висновки}
В роботі запропонована модифікована версія CoC, також відома як чиста система або система з однією аксіомою, разом
з предикативною або імпредикативною ієрархією зліченної кількості всесвітів. Ця система відома як консистентна,
підтримує сильну нормалізацію термів, та відвторює базове ядро усіх сучасних систем доведення теорем, таких як Coq, Lean, Agda, тощо.

{\bf Результати дослідження}
В результаті цього дослідження встановлені наступні відкриття:
1) Відсутність рекурсії робить неможливим кодування принципу індукції, необхідне послаблення хоча б для сигнатур
   рекурсивних типів, так звані Self-типи, запропоновані у мові Cedile, авторами Peng Fu та Aaron Stump\cite{Fu14}.
2) Однак для запезпечення виконання програм System F цілком достатньо для забезпечення бібліотеки часу виконання;
2) Теореми які можуть бути вираженими без конструктора нерухомої точки, більше відповідають категорній семантиці;
3) Ця система може бути природнім чином транпортована у нетипизовані лямбда числення та їх евалуатори, що розширює
   область застосування майже на усі інтерпретатори.
4) Якщо обмежити розмір інтерпретатор та його програм розміром кеша первого рівня,
   то швидкість інтерпретації лямбда контекстів буде на рівні JIT або native.

{\bf Переваги над існуючими аналогічними рішеннями}.
1) рафінована версія типового верифікатора на 300 рядків; Мінімальність ядра дає змогу швидко переконатися в коректності та здійснити ревью;
2) підтримка предикативної та імпредикативної ієрархій, як елемент конфігурації {\bf PTS$^\infty$};
3) евалуатор Erlang більш ефективний ніж вбудовування в Haskell;
4) мова {\bf PTS$^\infty$} використувється для специфікації нескінченних процесів.

{\bf Наукове та виробниче використання}.
1) Ця мова може використовуватися як сертифікована ядро для додатків з підвищеними вимогами до якості,
такі як фінансові додатки, математичні, або інші теми, які потребують перевірки тотальності функцій;
2) Ця мова може використовуватися як вбудовувана бібліотека;
3) В академії {\bf PTS$^\infty$} може використовуватися як дидактичний інструмент з логіки, систем типів, лямбда численнню, функціональним мовам програмування.

{\bf Перспективи подальших досліджень}.
1) Розширення спектру цільових мов та доведення семантики у cubicaltt;
2) Побудова екстрактор в опмитальний лямбда евалуатор з {\bf PTS$^\infty$};
3) Побудова сертифікованого інтерпретатора на Rust як заміна Erlang;
4) Залучення принципу індукції в {\bf PTS$^\infty$} в майбутньому.

\section{Подяки}
Висловлюється подяка усім дописувичам Групоїд Інфініті, хто допоміг уникнути помилок в TeX та Erlang файлах.
Також подяка всім рідним, хто підтримує нас.

\bibliographystyle{plain}
\bibliography{pts_ua}

\end{document}
