<!DOCTYPE html><html><head><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="author" content="Maxim Sokhatsky"><meta name="twitter:site" content="@5HT"><meta name="twitter:creator" content="@5HT"><meta property="og:type" content="website"><meta property="fb:app_id" content="118554188236439"><meta property="og:url" content="https://groupoid.space"><meta property="og:title" content="GROUPOЇD"><meta property="og:description" content="Formalization of Mathematics"><link rel="stylesheet" href="https://groupoid.space/main.css?v=31"><title>HOMOTOPY</title><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script><script>window.MathJax = { jax: ["input/TeX", "input/MathML", "input/AsciiMath", "output/CommonHTML", "output/NativeMML"],
                        TeX: { extensions: ["AMSmath.js", "AMSsymbols.js", "autoload-all.js"] },
                        extensions: ["tex2jax.js", "asciimath2jax.js", "mml2jax.js", "MathMenu.js", "MathZoom.js"],
                        "HTML-CSS": { imageFont: null },
                        AuthorInit: function() {
                            MathJax.Hub.Register.StartupHook("TeX AMSmath Ready", function() {
                                var TEX = MathJax.InputJax.TeX;
                                TEX.Definitions.Add({
                                    macros: {
                                      llparenthesis: ['Macro', '\\mathopen{\u2987}'],
                                      rrparenthesis: ['Macro', '\\mathclose{\u2988}'],
                                      llbracket:     ['Macro', '\\mathopen{\u27E6}'],
                                      rrbracket:     ['Macro', '\\mathclose{\u27E7}'],
                                      incmap:        ['Macro', '\\mathclose{\u21AA}'],
                                    }
                                });
                            });
                        },
                        tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']],
                                   processEscapes: true }
                    };
</script></head><body class="content"><header class="header"><div class="header__titles"><h1 class="header__title">Homotopy Type System</h1><h4 class="header__subtitle">Type theory with two equalities</h4></div></header><article class="main"><div class="exe"><section><h1>SYNOPSIS</h1></section><aside><a href="https://github.com/5HT">5HT</a><br><a href="https://github.com/forked-from-1kasper">Siegmentation Fault</a><time>28 JUN 2021</time><p>The HTS language proposed by Voevodsky exposes two different presheaf models of type theory:
the inner one is homotopy type system presheaf that models HoTT and the outer one is traditional Martin-Löf
type system presheaf that models set theory with UIP. The motivation behind this doubling is to
have an ability to express semisemplicial types. Theoretical work on merging meta-theoretical
and homotopical languages was continued in <a href="https://arxiv.org/pdf/1705.03307.pdf">2LTT</a> [Anenkov, Capriotti, Kraus, Sattler].
</p></aside><section><div class="macro"><div class="macro__col"><h3 id="pure"><b>PTS</b></h3><ol><li><a href="#univ">UNI</a></li><li><a href="#pi">PI</a></li></ol></div><div class="macro__col"><h3 id="mltt"><b>MLTT</b></h3><ol><li><a href="#univ">UNI</a></li><li><a href="#pi">PI</a></li><li><a href="#sigma">SIGMA</a></li><li><a href="#id">ID</a></li><li><a href="#induction">INDUCT</a></li></ol></div><div class="macro__col"><h3 id="homotopy"><b>CCHM</b></h3><ol><li><a href="#univ">UNI</a></li><li><a href="#pi">PI</a></li><li><a href="#sigma">SIGMA</a></li><li><a href="#path">INTERVAL</a></li><li><a href="#glue">GLUE</a></li><li><a href="#induction">HIT</a></li></ol></div><div class="macro__col"><h3 id="hts"><b>HTS</b></h3><ol><li><a href="#univ">UNI</a></li><li><a href="#pi">PI</a></li><li><a href="#sigma">SIGMA</a></li><li><a href="#id">ID</a></li><li><a href="#path">INTERVAL</a></li><li><a href="#glue">GLUE</a></li><li><a href="#induction">HIT</a></li></ol></div></div><p>While we are on our road to HTS with Lean-like tactic language, currently we are at the stage of regular
cubical (HoTT) type checker with CHM-style primitives, or more general CCHM type checker.
You may try it at Github: <a href="https://github.com/groupoid/anders">groupoid/anders</a>.
</p><code>$ ./anders.native
Anders theorem prover [MLTT].

   invoke = anders | anders list
     list = [] | command list
  command = check filename     | lex filename
          | parse filename     | help
          | cubicaltt filename | girard
          | trace</code><br><p>Anders is idiomatic and educational. We carefully draw the favourite
Lean-compatible syntax to fit 130 LOC in Menhir, the MLTT core (based on Mini-TT)
is 500 LOC and pretypes presheaf is another 500 LOC. The MLTT hyperprover core
in Clojure is <a href="https://gist.github.com/5HT/2415f9945e92d7fc364f592a1abc2f93">expressible</a> in 150 LOC.</p><br></section><section><h1>SYNTAX</h1><p>The syntax resembles original syntax of the reference CCHM type checker cubicaltt [Cohen, Coquand, Huber, Mörtberg], slightly compatible with Lean.
Here will be used Menhir BNF nonation as type checker is written in OCaml.</p><p><b>Keywords</b>.
The words of a language consist of keywords or identifiers. The keywords are following:
<b>module</b>, <b>where</b>, <b>import</b>, <b>option</b>, <b>def</b>, <b>axiom</b>, <b>postulate</b>, <b>theorem</b>,
<b>(</b>, <b>)</b>, <b>[</b>, <b>]</b>, <b>&lt;</b>, <b>&gt;</b>, <b>&#47;</b>, <b>.1</b>, <b>.2</b>, <b>Π</b>,
<b>Σ</b>, <b>,</b>, <b>λ</b>, <b>×</b>, <b>→</b>, <b>:</b>, <b>:=</b>, <b>U</b>, <b>V</b>, <b>∧</b>, <b>∨</b>, <b>-</b>, <b>+</b>,
<b>@</b>, <b>PathP</b>, <b>transp</b>, <b>hcomp</b>, <b>i₀</b>, <b>i₁</b>, <b>interval</b>, <b>inductive</b>,
<b>record</b>, <b>Glue</b>, <b>glue</b>, <b>unglue</b>.</p><p><b>Indentifiers</b>. Identifiers support UTF-8. Indentifiers couldn't start
with <b>:</b>, <b>-</b>, <b>→</b>. Sample identifiers:</p><code>¬-of-∨, 1=1, is-?, =, $^~]!005x, ∞, x→Nat, f'</code><br><p><b>Modules</b>. Modules represent files with declarations. More accurate,
BNF notation of module consists of imports, options and declarations.</p><p><b>Imports</b>. The import construction supports file folder
structure (without file extensions) by using reserved symbol <b>&#47;</b>
for hierarchy walking.</p><p><b>Options</b>. Each option holds bool value. Language supports following options:
1) <b>girard</b> (enables U : U);
2) <b>pre-eval</b> (normalization cache);
3) <b>impredicative</b> (infinite hierarchy with impredicativity rule);</p><code>path : IDENT | IDENT DIRSEP path
file : MODULE IDENT WHERE content
content : line content | EOF
line :
   | IMPORT path
   | OPTION IDENT IDENT
   | declarations</code><p>File header sample:</p><code>module sample where
import experiments/path
option girard false</code><br><p><b>Declarations</b>. Language supports following top level declarations:
1) <b>axiom</b> (non-computable declaration that breakes normalization);
2) <b>postulate</b> (alternative or inverted axiom that can preserve consistency);
3) <b>definition</b> (almost any explicit term or type in type theory);
5) <b>lemma</b> (helper in big game).
4) <b>theorem</b> (something valuable or complex enough).</p><code>vars : ident vars | ident
lense : LPARENS vars COLON exp1 RPARENS
telescope : lense telescope
params : telescope | []

declarations:
   | DEF IDENT params DEFEQ exp1
   | DEF IDENT params COLON exp1 DEFEQ exp1
   | AXIOM IDENT params COLON exp1</code><br><p>Sample declarations. For example, signature <b>isProp (A : U)</b> of
type <b>U</b> could be defined as normalization-blocking axiom
without proof-term or by providing proof-term as definition.</p><code>axiom isProp (A : U) : U
def isSet (A : U) : U := Π (a b : A)
    (x y : Path A a b), Path (Path A a b) x y</code><p>In this example <b>(A : U)</b>, <b>(a b : A)</b> and <b>(x y : Path A a b)</b> are
called telescopes. Each telescope consists of a series of lenses or empty.
Each lense provides a set of variable of the same type. Telescope
defines parameters of a declaration. Types in telescope,
type of declaration and proof-term are a language expressions <b>exp1</b>.</p><p><b>Expressions</b>. All atomic language expressions are grouped
by four categories:
<b>exp0</b> (pair constructions),
<b>exp1</b> (non neutral constructions),
<b>exp2</b> (path and pi applcations),
<b>exp3</b> (neutral constructions).</p><code>exp0 :
  | exp1 COMMA exp0
  | exp1</code><br><code>exp1:
  | LAM telescope COMMA exp1
  | PI telescope COMMA exp1     | exp2 ARROW exp1
  | SIGMA telescope COMMA exp1  | exp2 PROD exp1
  | LT vars GT exp1             | exp2</code><br><p>The LR parsers demand to define <b>exp1</b> as expressions that
cannot be used (without a parens enclosure) as a right part of
left-associative application for both Path and Pi lambdas.</p><code>exp2 :
  | exp2 exp3
  | exp2 APPFORMULA exp3
  | exp3</code><br><p>Universe indecies <b>V</b> (pretypes), <b>U</b> (inner fibrant) and <b>S</b> (outer strict)
are using unicode subscript letters that are already processed in lexer.</p><code>exp3:
  | HOLE          | PRE
  | KAN           | exp3 FST
  | exp3 SND      | NEGATE exp3
  | exp3 AND exp3 | exp3 OR exp3
  | PATHP exp3    | TRANSP exp3 exp3
  | IDENT         | NO
  | LPARENS exp0 RPARENS | STRICT</code><br><h1>SEMANTICS</h1><p>The idea is to have a unified layered type checker, so you can disbale/enable
any MLTT-style inference, assign types to universes and enable/disable hierachies.
This will be done by providing linking API for pluggable presheaf modules.
We selected 5 levels of type checker awareness from universes and pure type systems
up to synthetic language of homotopy type theory. Each layer corresponds to its
presheaves with separate configuration for universe hierarchies.</p><code>inductive lang : U
  | UNI: cosmos → lang
  | PI: pure lang → lang
  | SIGMA: total lang → lang
  | PATH: homotopy lang → lang
  | GLUE: gluening lang → lang
  | HIT: hit lang → lang</code><br><p>We want to mention here with homage to its authors all categorical
models of dependent type theory:  Comprehension Categories (Grothendieck, Jacobs),
LCCC (Seely), D-Categories and CwA (Cartmell), CwF (Dybjer), C-Systems (Voevodsky),
Natural Models (Awodey). While we can build some transports between them,
we leave this excercise for our <a href="https://groupoid.space">mathematical components</a> library.</p><br><h2 id="univ">Universe Hierarchies</h2><p>Language supports Agda-style hierarchy of universes: fibrant, interval pretypes and strict omega
with explicit level manipulation. All universes are bounded with preorder
$$
   Fibrant_j \prec Pretypes_k \prec Strict_l,
$$</p><p>in which $j,k,l$ are bounded with equation:
$$
   j < k < l.
$$</p><p>Large elimination to upper universes is prohibited.</p><code>inductive cosmos : U
  | fibrant: nat → cosmos
  | pretypes: nat → cosmos
  | strict: nat → cosmos
  | omega: cosmos</code><br><h2>Dependent Types</h2><p><b>Definition</b> (Type).
A type is interpreted as a presheaf $A$, a family of sets $A_I$ with restriction maps
$u \mapsto u\ f, A_I \rightarrow A_J$ for $f: J\rightarrow I$. A dependent type
B on A is interpreted by a presheaf on category of elements of $A$: the objects
are pairs $(I,u)$ with $u : A_I$ and morphisms $f: (J,v) \rightarrow (I,u)$ are
maps $f : J \rightarrow$ such that $v = u\ f$. A dependent type B is thus given
by a family of sets $B(I,u)$ and restriction maps $B(I,u) \rightarrow B(J,u\ f)$.</p><p>We think of $A$ as a type and $B$ as a family of presheves $B(x)$ varying $x:A$.
The operation $\Pi(x:A)B(x)$ generalizes the semantics of
implication in a Kripke model.</p><p id="pi"><b>Defintion</b> (Pi). An element $w:[\Pi(x:A)B(x)](I)$ is a family<of>functions $w_f : \Pi(u:A(J))B(J,u)$ for $f : J \rightarrow I$ such</of><that>$(w_f u)g=w_{f\ g}(u\ g)$ when $u:A(J)$ and $g:K\rightarrow J$.</that></p><code>inductive pure (lang: U) : U
  | var: name → nat → pure lang
  | pi: name → nat → lang → lang → pure lang
  | lambda: name → nat → lang → lang → pure lang
  | app: lang → lang → pure lang</code><br><p id="sigma"><b>Defintion</b> (Sigma). The set $\Sigma(x:A)B(x)$ is the set<of>pairs $(u,v)$ when $u:A(I),v:B(I,u)$ and restriction map $(u,v)\ f=(u\ f,v\ f)$.</of></p><code>inductive total (lang: U) : U
  | sigma: name → lang → lang → total lang
  | pair: lang → lang → total lang
  | fst: lang → total lang
  | snd: lang → total lang</code><br><h2 id="path">Path Types</h2><p>The fundamental development of equality inside MLTT
provers led us to the notion of ∞-groupoid as spaces.
In this way Path identity type appeared in the core
of type checker along with De Morgan algebra on
built-in interval type.</p><code>inductive homotopy (lang: U) : U
  | path: lang → lang → lang → homotopy lang
  | plam: name → lang → lang → homotopy lang
  | papp: lang → lang → homotopy lang
  | interval: homotopy lang
  | zero: homotopy lang
  | one: homotopy lang
  | meet: lang → lang → homotopy lang
  | join: lang → lang → homotopy lang
  | neg: lang → homotopy lang
  | transp: lang → lang → lang → homotopy lang
  | hcomp: lang → lang → homotopy lang</code><br><p><b>Definition</b> (Cubical Presheaf $\mathbb{I}$).
The identity types modeled with another presheaf, the presheaf on Lawvere
category of distributive lattices (theory of De Morgan algebras) denoted
with $\Box$ &mdash; $\mathbb{I} : \Box^{op} \rightarrow \mathrm{Set}$.</p><p><b>Properties of $\mathbb{I}$</b>. The presheaf $\mathbb{I}$:
i) has to distinct global elements $0$ and $1$ (B$_1$);
ii) $\mathbb{I}$(I) has a decidable equality for each $I$ (B$_2$);
iii) $\mathbb{I}$ is tiny so the path functor $X \mapsto X^\mathbb{I}$ has right adjoint (B$_3$).;
iv) $\mathbb{I}$ has meet and join (connections).</p><p>While having pretypes universe <b>V</b> with interval and
associated De Morgan algebra is enough to perform DNF normalization
and proving some basic statements about path, including: contractability of singletons,
homotopy transport, congruence, functional extensionality; it is not enough for
proving β rule for Path type or path composition.</p><p>Generalized transport <b>transp</b> adresses first problem of deriving the
computational β rule for Path types:</p><code>def Equ (A : U) (x y : A) : U := PathP (&lt;_&gt; A) x y
def refl (A : U) (x : A) : Equ A x x := &lt;_&gt; x
def singl (A : U) (a : A) : U ≔ Σ (x: A), Equ A a x
def eta (A : U) (a : A) : singl A a ≔ (a, refl A a)
def subst (A: U) (P: A → U) (a b: A) (p: Path A a b) (e: P a)
  : P b := transp (&lt;i&gt; P (p @ i)) 0 e
def trans (A B: U) (p: PathP (&lt;_&gt; U) A B) (a: A): B := transp p 0 a
def J (A: U) (x: A) (C: D A) (d: C x x (refl A x)) (y: A) (p: Equ A x y)
  : C x y p ≔ subst (singl A x) (λ (z: singl A x), C x (z.1) (z.2)) (eta A x) (y, p) (contr A x y p) d
def trans_comp (A : U) (a : A)
  : Equ A a (trans A A (&lt;i&gt; A) a) ≔ &lt;j&gt; transp (&lt;_&gt; A) -j a
def contr (A : U) (a b : A) (p : Equ A a b)
  : Equ (singl A a) (eta A a) (b, p) ≔ &lt;i&gt; (p @ i, &lt;j&gt; p @ i /\ j)
def subst_comp (A: U) (P: A → U) (a: A) (e: P a)
  : Equ (P a) e (subst A P a a (refl A a) e) ≔ trans_comp (P a) e

theorem Path-β (A : U) (a : A) (C : D A) (d: C a a (refl A a))
  : Equ (C a a (refl A a)) d (J A a C d a (refl A a))
  ≔ subst_comp (singl A a) (λ (z: singl A a), C a (z.1) (z.2)) (eta A a) d</code><br><p>Homogeneous composition <b>hcomp</b> is the answer to second:
with <b>hcomp</b> and <b>transp</b> one can express path composition,
groupoid, category of groupoids (groupoid interpretation and internalization in type theory).
One of the main roles of homogeneous composition is to be a carrier in [higher]
inductive type constructors for calculating of homotopy colimits and
direct encoding of CW-complexes (or internal models as gluening of pushout cells).</p><br><h2 id="induction">Higher Inductive Types</h2><p>The further development of induction inside MLTT provers led
to the theory of polynomial functors and well-founded trees,
known in programming languages as inductive types with <b>inductive</b>
and <b>record</b> core primitives.</p><p>Inductive types could be encoded in PTS/Cedile using non-recursive
representation of Bohm-Berarducci schemes or with categorical impredicative
encoding by Steve Awodey. We want to have optional infinite
impredicative universe in type checker for such experiments in PTS mode.</p><p>Anders supports Lean-compatible inductive definition so we can
copy-paste term between Lean and Anders.
</p><code>inductive tele (A: U) : U | emp: tele A | tel: name → A → tele A → tele A
inductive branch (A: U) : U | br: name → branch A | args: list name → A → branch A
inductive label (A: U) : U | lab: name → label A | t: tele A → label A

inductive hit (lang: U)
  | intro: name → tele lang → list (label lang) → hit lang
  | case: name → lang → list (branch lang) → hit lang
  | ctor: name → list lang → hit lang
  | htor: name → list lang → list lang → lang → hit lang</code><p>The non-well-founded trees or infinite coinductive trees
are useful for modeling infinite processes and are part
of Milner's Pi-calculus. Coinductive streams could be found in many MLTT base libraries.
</p><h2 id="glue">Glue Types</h2><p>Glue Types are needed to prove univalence. The basic theoretical introduction
of Artin Gluening could be found in SGA-4, Jonstone.</p><code>inductive gluening (lang: U) : U
  | Glue: lang → lang → lang → gluening lang
  | glue: lang → lang → gluening lang
  | unglue: lang → lang → gluening lang</code><br></section><section><h1>Bibliography</h1><p><center><table cellspacing=5><tr><td width=5><img src="https://n2o.space/img/pdf.jpg" width=35></td><td width=400>
<a href="https://github.com/groupoid/groupoid.space/blob/master/articles/mltt/mltt.pdf">
<h3>Issue I: Internalizing MLTT</h3>
</a></td></tr></table></center>
</p><h2>MLTT and PTS</h2><p><a href="https://raw.githubusercontent.com/groupoid.space/misc/references/01.Lof72.txt">[1]</a>. P. Martin-Löf and G. Sambin, The Theory of Types. Studies in proof theory, 1972.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/02.Lof84.txt">[2]</a>. P. Martin-Löf and G. Sambin, Intuitionistic type theory. Studies in proof theory, Bibliopolis, 1984.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/03.Coq88.txt">[3]</a>. T. Coquand and G. Huet, “The calculus of constructions,” in Information and Computation, (Duluth, MN, USA), pp. 95–120, Academic Press, Inc., 1988.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/04.Hofmann96.txt">[4]</a>. M. Hofmann and T. Streicher, “The groupoid interpretation of type theory,” in In Venice Festschrift, pp. 83–111, Oxford University Press, 1996.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/05.Henk93.txt">[5]</a>. H. P. Barendregt, “Lambda calculi with types,” in Handbook of Logic in Computer Science (Vol. 2) (S. Abramsky, D. M. Gabbay, and S. E. Maibaum, eds.), (New York, NY, USA), pp. 117–309, Oxford University Press, Inc., 1992.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/06.Erik97.txt">[6]</a>. S. P. Jones and E. Meijer, “Henk: A typed intermediate language,” in In Proc. First Int’l Workshop on Types in Compilation, 1997.
</p><h2>Categorical Methods</h2><p><a href="https://raw.githubusercontent.com/groupoid.space/misc/references/10.Hermida95.txt">[10]</a>. C. Hermida and B. Jacobs, “Fibrations with indeterminates: Contextual and functional completeness for polymorphic lambda calculi,” Mathematical Structures in Computer Science, vol. 5, pp. 501–531, 1995.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/11.Curien08.txt">[11]</a>. P.-L. Curien, “Category theory: a programming language-oriented introduction,” 2008.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/12.MacLane71.txt">[12]</a>. S. MacLane, Categories for the Working Mathematician. New York: Springer-Verlag, 1971. Graduate Texts in Mathematics, Vol. 5.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/13.Lawvere09.txt">[13]</a>. F. Lawvere and S. Schanuel, Conceptual Mathematics: A First Introduction to Categories. Cambridge University Press, 2009.
</p><h2>Categorical Models of Type Theory</h2><p><a href="https://raw.githubusercontent.com/groupoid.space/misc/references/20.Dybjer08.txt">[20]</a>. A. Buisse and P. Dybjer, “The interpretation of intuitionistic type theory in locally cartesian closed categories – an intuitionistic perspective,” Electron. Notes Theor. Comput. Sci., vol. 218, pp. 21–32, Oct. 2008.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/21.Clairambault05.txt">[21]</a>. P. Clairambault, “From categories with families to locally cartesian closed categories,”
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/22.Abel08.txt">[22]</a>. A. Abel, T. Coquand, and P. Dybjer, “On the algebraic foundation of proof assistants for intuitionistic type theory,” in Functional and Logic Programming (J. Garrigue and M. V. Hermenegildo, eds.), (Berlin, Heidelberg), pp. 3–13, Springer Berlin Heidelberg, 2008.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/23.Seely84.txt">[23]</a>. R. A. Seely, “Locally cartesian closed categories and type theory,” in Mathematical proceedings of the Cambridge philosophical society, vol. 95, pp. 33–48, Cambridge University Press, 1984.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/24.Curien14.txt">[24]</a>. P.-L. Curien, R. Garner, and M. Hofmann, “Revisiting the categorical interpretation of dependent type theory,” Theoretical Computer Science, vol. 546, pp. 99–119, 2014.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/25.Castellan14.txt">[25]</a>. S. Castellan, “Dependent type theory as the initial category with families,” Internship Report, 2014.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/26.Voevodsky14.txt">[26]</a>. V. Voevodsky, “A c-system defined by a universe in a category,” 2014.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/27.Dybjer95.txt">[27]</a>. P. Dybjer, “Internal type theory,” in International Workshop on Types for Proofs and Programs, pp. 120–134, Springer, 1995.
</p><h2>Identity Types</h2><p><a href="https://raw.githubusercontent.com/groupoid.space/misc/references/30.Bishop67.txt">[30]</a>. E. Bishop, Foundations of constructive analysis. 1967.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/31.Nordstrom90.txt">[31]</a>. B.Nordström, K.Petersson, and J.M.Smith, Programming in Martin-Löf’s type theory, vol. 200. Oxford University Press Oxford, 1990.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/32.Hermida98.txt">[32]</a>. C. Hermida and B. Jacobs, “Structural induction and coinduction in a fibrational setting,” Information and computation, vol. 145, no. 2, pp. 107–152, 1998.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/33.Barthe00.txt">[33]</a>. G. Barthe, V. Capretta, and O. Pons, “Setoids in type theory,” 2000.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/34.Voevodsky15.txt">[34]</a>. V. Voevodsky, “A c-system defined by a universe category,” Theory Appl. Categ, vol. 30, no. 37, pp. 1181–1215, 2015.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/35.Sozeau.txt">[35]</a>. M. Sozeau and N. Tabareau, “Internalizing intensional type theory,”
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/36.Selsam16.txt">[36]</a>. D. Selsam and L. de Moura, “Congruence closure in intensional type theory,” in International Joint Conference on Automated Reasoning, pp. 99–115, Springer, 2016.
</p><h2>Inductive Types</h2><p><a href="https://raw.githubusercontent.com/groupoid.space/misc/references/40.Bohm85.txt">[40]</a>. C. Böhm and A. Berarducci, “Automatic synthesis of typed lambda- programs on term algebras,” in Theoretical Computer Science, vol. 39, pp. 135–154, 1985.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/41.Pfenning89.txt">[41]</a>. F. Pfenning and C. Paulin-Mohring, “Inductively defined types in the calculus of constructions,” in Mathematical Foundations of Programming Semantics, 5th International Conference, Tulane University, New Orleans, Louisiana, USA, March 29 - April 1, 1989, Proceedings, pp. 209–228, 1989.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/42.Wadler90.txt">[42]</a>. P. Wadler in Recursive types for free, manuscript, 1990.N. Gambino and M. Hyland, “Wellfounded trees and dependent polynomial functors,” in International Workshop on Types for Proofs and Programs, pp. 210–225, Springer, 2003.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/43.Gambino03.txt">[43]</a>.N. Gambino and M. Hyland, “Wellfounded trees and dependent polynomial functors,” in International Workshop on Types for Proofs and Programs, pp. 210–225, Springer, 2003.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/44.Dybjer94.txt">[44]</a>. P. Dybjer in Inductive families, vol. 6, pp. 440–465, Springer, 1994.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/45.Jacobs97.txt">[45]</a>. B. Jacobs and J. Rutten in A tutorial on (co) algebras and (co) induction, vol. 62, pp. 222–259, EUROPEAN ASSOCIATION FOR THEORETICAL COMPUTER, 1997.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/46.Vene00.txt">[46]</a>. V. Vene, Categorical programming with inductive and coinductive types. Tartu University Press, 2000.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/47.Basold16.txt">[47]</a>. H. Basold and H. Geuvers, “Type theory based on dependent inductive and coinductive types,” in Proceedings of the 31st Annual ACM/IEEE Symposium on Logic in Computer Science, pp. 327–336, ACM, 2016.
</p><h2>Higher Inductive Types</h2><p><a href="https://raw.githubusercontent.com/groupoid.space/misc/references/50.Hofmann94.txt">[50]</a>. M. Hofmann and T. Streicher, “The groupoid model refutes uniqueness of identity proofs,” in Logic in Computer Science, 1994. LICS’94. Proceedings., Symposium on, pp. 208–212, IEEE, 1994.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/51.Jacobs99.txt">[51]</a>. B. Jacobs, Categorical logic and type theory, vol. 141. Elsevier, 1999.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/52.Joyal14.txt">[52]</a>. A. Joyal, “Categorical homotopy type theory,” Slides from a talk at MIT dated, vol. 17, 2014.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/53.HoTT13.txt">[53]</a>. T. Coquand, P. Martin-Löf, V. Voevodsky, A. Joyal, A. Bauer, S. Awodey, M. Sozeau, M. Shulman, D. Licata, Y. Bertot, P. Dybjer, and N. Gambino, Homotopy Type Theory: Univalent Foundations of Mathematics. 2013.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/54.Mortberg17.txt">[54]</a>. C. Cohen, T. Coquand, S. Huber, and A. Mörtberg in Cubical Type Theory: a constructive interpretation of the univalence axiom, vol. abs/1611.02108, 2017.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/55.Shulman15.txt">[55]</a>. B. Ahrens, K. Kapulkin, and M. Shulman, “Univalent categories and the rezk completion,” in Extended Abstracts Fall 2013 (M. d. M. González, P. C. Yang, N. Gambino, and J. Kock, eds.), (Cham), pp. 75– 76, Springer International Publishing, 2015.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/56.Orton17.txt">[56]</a>. I. Orton and A. M. Pitts, “Axioms for modelling cubical type theory in a topos,” arXiv preprint arXiv:1712.04864, 2017.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/57.Huber16.txt">[57]</a>. S. Huber, “Cubical intepretations of type theory,” 2016.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/58.Huber17.txt">[58]</a>. S. Huber, “Canonicity for cubical type theory,” Journal of Automated Reasoning, pp. 1–38, 2017.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/59.Angiuli16.txt">[59]</a>. C. Angiuli, R. Harper, and T. Wilson, “Computational higher type theory i: Abstract cubical realizability,” arXiv preprint arXiv:1604.08873, 2016.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/60.Angiuli16.txt">[60]</a>. C. Angiuli and R. Harper, “Computational higher type theory ii: Dependent cubical realizability,” arXiv preprint arXiv:1606.09638, 2016.
<a href="https://raw.githubusercontent.com/groupoid.space/misc/references/61.Coquand18.txt">[61]</a>. T.Coquand, S.Huber, and A.Mörtberg , “On Higher Inductive Types in Cubical Type Theory”, arXiv preprint arXiv:1802.01170, 2018.</p></section></div></article><footer class="footer"><a href="https://github.com/groupoid/"><img class="footer__logo" src="https://longchenpa.guru/seal.png" width="50"></a><span class="footer__copy">2016&mdash;2021 &copy; <a href="//5ht.co/" style="color:Lavender;">Максим Сохацький</a></span></footer><script src="https://groupoid.space/bundle.js?v=7"></script><script src="https://groupoid.space/highlight.js?v=17"></script></body></html>